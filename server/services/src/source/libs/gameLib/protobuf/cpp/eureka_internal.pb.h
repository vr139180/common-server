// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eureka_internal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_eureka_5finternal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_eureka_5finternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_eureka_5finternal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_eureka_5finternal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_eureka_5finternal_2eproto;
namespace PRO {
class Erk_EurekaBind_ack;
struct Erk_EurekaBind_ackDefaultTypeInternal;
extern Erk_EurekaBind_ackDefaultTypeInternal _Erk_EurekaBind_ack_default_instance_;
class Erk_EurekaBind_req;
struct Erk_EurekaBind_reqDefaultTypeInternal;
extern Erk_EurekaBind_reqDefaultTypeInternal _Erk_EurekaBind_req_default_instance_;
class Erk_EurekaUpdate_ntf;
struct Erk_EurekaUpdate_ntfDefaultTypeInternal;
extern Erk_EurekaUpdate_ntfDefaultTypeInternal _Erk_EurekaUpdate_ntf_default_instance_;
class Erk_Eureka_sync;
struct Erk_Eureka_syncDefaultTypeInternal;
extern Erk_Eureka_syncDefaultTypeInternal _Erk_Eureka_sync_default_instance_;
class Erk_ServiceBind_ack;
struct Erk_ServiceBind_ackDefaultTypeInternal;
extern Erk_ServiceBind_ackDefaultTypeInternal _Erk_ServiceBind_ack_default_instance_;
class Erk_ServiceBind_req;
struct Erk_ServiceBind_reqDefaultTypeInternal;
extern Erk_ServiceBind_reqDefaultTypeInternal _Erk_ServiceBind_req_default_instance_;
class Erk_ServiceRegist_Confirm;
struct Erk_ServiceRegist_ConfirmDefaultTypeInternal;
extern Erk_ServiceRegist_ConfirmDefaultTypeInternal _Erk_ServiceRegist_Confirm_default_instance_;
class Erk_ServiceRegist_ack;
struct Erk_ServiceRegist_ackDefaultTypeInternal;
extern Erk_ServiceRegist_ackDefaultTypeInternal _Erk_ServiceRegist_ack_default_instance_;
class Erk_ServiceRegist_req;
struct Erk_ServiceRegist_reqDefaultTypeInternal;
extern Erk_ServiceRegist_reqDefaultTypeInternal _Erk_ServiceRegist_req_default_instance_;
class Erk_ServiceRegist_req_ExtsEntry_DoNotUse;
struct Erk_ServiceRegist_req_ExtsEntry_DoNotUseDefaultTypeInternal;
extern Erk_ServiceRegist_req_ExtsEntry_DoNotUseDefaultTypeInternal _Erk_ServiceRegist_req_ExtsEntry_DoNotUse_default_instance_;
class Erk_ServiceShutdown_ntf;
struct Erk_ServiceShutdown_ntfDefaultTypeInternal;
extern Erk_ServiceShutdown_ntfDefaultTypeInternal _Erk_ServiceShutdown_ntf_default_instance_;
class Erk_ServiceSubscribe_ack;
struct Erk_ServiceSubscribe_ackDefaultTypeInternal;
extern Erk_ServiceSubscribe_ackDefaultTypeInternal _Erk_ServiceSubscribe_ack_default_instance_;
class Erk_ServiceSubscribe_req;
struct Erk_ServiceSubscribe_reqDefaultTypeInternal;
extern Erk_ServiceSubscribe_reqDefaultTypeInternal _Erk_ServiceSubscribe_req_default_instance_;
class Erk_ServiceSubscribe_req_svrinfo;
struct Erk_ServiceSubscribe_req_svrinfoDefaultTypeInternal;
extern Erk_ServiceSubscribe_req_svrinfoDefaultTypeInternal _Erk_ServiceSubscribe_req_svrinfo_default_instance_;
class EurekaServerNode;
struct EurekaServerNodeDefaultTypeInternal;
extern EurekaServerNodeDefaultTypeInternal _EurekaServerNode_default_instance_;
class ServerNode;
struct ServerNodeDefaultTypeInternal;
extern ServerNodeDefaultTypeInternal _ServerNode_default_instance_;
class ServerNode_ExtsEntry_DoNotUse;
struct ServerNode_ExtsEntry_DoNotUseDefaultTypeInternal;
extern ServerNode_ExtsEntry_DoNotUseDefaultTypeInternal _ServerNode_ExtsEntry_DoNotUse_default_instance_;
class Svr_LiveTick_ntf;
struct Svr_LiveTick_ntfDefaultTypeInternal;
extern Svr_LiveTick_ntfDefaultTypeInternal _Svr_LiveTick_ntf_default_instance_;
class Svr_ServiceBindService_ack;
struct Svr_ServiceBindService_ackDefaultTypeInternal;
extern Svr_ServiceBindService_ackDefaultTypeInternal _Svr_ServiceBindService_ack_default_instance_;
class Svr_ServiceBindService_req;
struct Svr_ServiceBindService_reqDefaultTypeInternal;
extern Svr_ServiceBindService_reqDefaultTypeInternal _Svr_ServiceBindService_req_default_instance_;
class Svr_ServiceBindService_req_MyextsEntry_DoNotUse;
struct Svr_ServiceBindService_req_MyextsEntry_DoNotUseDefaultTypeInternal;
extern Svr_ServiceBindService_req_MyextsEntry_DoNotUseDefaultTypeInternal _Svr_ServiceBindService_req_MyextsEntry_DoNotUse_default_instance_;
}  // namespace PRO
PROTOBUF_NAMESPACE_OPEN
template<> ::PRO::Erk_EurekaBind_ack* Arena::CreateMaybeMessage<::PRO::Erk_EurekaBind_ack>(Arena*);
template<> ::PRO::Erk_EurekaBind_req* Arena::CreateMaybeMessage<::PRO::Erk_EurekaBind_req>(Arena*);
template<> ::PRO::Erk_EurekaUpdate_ntf* Arena::CreateMaybeMessage<::PRO::Erk_EurekaUpdate_ntf>(Arena*);
template<> ::PRO::Erk_Eureka_sync* Arena::CreateMaybeMessage<::PRO::Erk_Eureka_sync>(Arena*);
template<> ::PRO::Erk_ServiceBind_ack* Arena::CreateMaybeMessage<::PRO::Erk_ServiceBind_ack>(Arena*);
template<> ::PRO::Erk_ServiceBind_req* Arena::CreateMaybeMessage<::PRO::Erk_ServiceBind_req>(Arena*);
template<> ::PRO::Erk_ServiceRegist_Confirm* Arena::CreateMaybeMessage<::PRO::Erk_ServiceRegist_Confirm>(Arena*);
template<> ::PRO::Erk_ServiceRegist_ack* Arena::CreateMaybeMessage<::PRO::Erk_ServiceRegist_ack>(Arena*);
template<> ::PRO::Erk_ServiceRegist_req* Arena::CreateMaybeMessage<::PRO::Erk_ServiceRegist_req>(Arena*);
template<> ::PRO::Erk_ServiceRegist_req_ExtsEntry_DoNotUse* Arena::CreateMaybeMessage<::PRO::Erk_ServiceRegist_req_ExtsEntry_DoNotUse>(Arena*);
template<> ::PRO::Erk_ServiceShutdown_ntf* Arena::CreateMaybeMessage<::PRO::Erk_ServiceShutdown_ntf>(Arena*);
template<> ::PRO::Erk_ServiceSubscribe_ack* Arena::CreateMaybeMessage<::PRO::Erk_ServiceSubscribe_ack>(Arena*);
template<> ::PRO::Erk_ServiceSubscribe_req* Arena::CreateMaybeMessage<::PRO::Erk_ServiceSubscribe_req>(Arena*);
template<> ::PRO::Erk_ServiceSubscribe_req_svrinfo* Arena::CreateMaybeMessage<::PRO::Erk_ServiceSubscribe_req_svrinfo>(Arena*);
template<> ::PRO::EurekaServerNode* Arena::CreateMaybeMessage<::PRO::EurekaServerNode>(Arena*);
template<> ::PRO::ServerNode* Arena::CreateMaybeMessage<::PRO::ServerNode>(Arena*);
template<> ::PRO::ServerNode_ExtsEntry_DoNotUse* Arena::CreateMaybeMessage<::PRO::ServerNode_ExtsEntry_DoNotUse>(Arena*);
template<> ::PRO::Svr_LiveTick_ntf* Arena::CreateMaybeMessage<::PRO::Svr_LiveTick_ntf>(Arena*);
template<> ::PRO::Svr_ServiceBindService_ack* Arena::CreateMaybeMessage<::PRO::Svr_ServiceBindService_ack>(Arena*);
template<> ::PRO::Svr_ServiceBindService_req* Arena::CreateMaybeMessage<::PRO::Svr_ServiceBindService_req>(Arena*);
template<> ::PRO::Svr_ServiceBindService_req_MyextsEntry_DoNotUse* Arena::CreateMaybeMessage<::PRO::Svr_ServiceBindService_req_MyextsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PRO {

enum ERK_SERVICETYPE : int {
  ERK_SERVICE_NONE = 0,
  ERK_SERVICE_EUREKA = 1,
  ERK_SERVICE_DATAROUTER = 2,
  ERK_SERVICE_STATE = 3,
  ERK_SERVICE_GATE = 4,
  ERK_SERVICE_HOME = 5,
  ERK_SERVICE_LOGIN = 6,
  ERK_SERVICE_SVRROUTER = 7,
  ERK_SERVICE_UNION = 8,
  ERK_SERVICE_CHAT = 9,
  ERK_SERVICE_MAIL = 10,
  ERK_SERVICE_FRIEND = 11,
  ERK_SERVICE_FIGHTROUTER = 12,
  ERK_SERVICE_MATCHMAKING = 13,
  ERK_SERVICE_GAME = 14,
  ERK_SERVICE_DATASYNC = 15,
  ERK_SERVICE_MAX = 16,
  ERK_SERVICETYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ERK_SERVICETYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ERK_SERVICETYPE_IsValid(int value);
constexpr ERK_SERVICETYPE ERK_SERVICETYPE_MIN = ERK_SERVICE_NONE;
constexpr ERK_SERVICETYPE ERK_SERVICETYPE_MAX = ERK_SERVICE_MAX;
constexpr int ERK_SERVICETYPE_ARRAYSIZE = ERK_SERVICETYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERK_SERVICETYPE_descriptor();
template<typename T>
inline const std::string& ERK_SERVICETYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERK_SERVICETYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERK_SERVICETYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERK_SERVICETYPE_descriptor(), enum_t_value);
}
inline bool ERK_SERVICETYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERK_SERVICETYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERK_SERVICETYPE>(
    ERK_SERVICETYPE_descriptor(), name, value);
}
// ===================================================================

class EurekaServerNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.EurekaServerNode) */ {
 public:
  inline EurekaServerNode() : EurekaServerNode(nullptr) {}
  ~EurekaServerNode() override;
  explicit constexpr EurekaServerNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EurekaServerNode(const EurekaServerNode& from);
  EurekaServerNode(EurekaServerNode&& from) noexcept
    : EurekaServerNode() {
    *this = ::std::move(from);
  }

  inline EurekaServerNode& operator=(const EurekaServerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline EurekaServerNode& operator=(EurekaServerNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EurekaServerNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const EurekaServerNode* internal_default_instance() {
    return reinterpret_cast<const EurekaServerNode*>(
               &_EurekaServerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EurekaServerNode& a, EurekaServerNode& b) {
    a.Swap(&b);
  }
  inline void Swap(EurekaServerNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EurekaServerNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EurekaServerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EurekaServerNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EurekaServerNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EurekaServerNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EurekaServerNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.EurekaServerNode";
  }
  protected:
  explicit EurekaServerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kIidFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPortFieldNumber = 4,
  };
  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int64 iid = 1;
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // int64 token = 2;
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // int32 port = 4;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.EurekaServerNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int64_t iid_;
  int64_t token_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_EurekaBind_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_EurekaBind_req) */ {
 public:
  inline Erk_EurekaBind_req() : Erk_EurekaBind_req(nullptr) {}
  ~Erk_EurekaBind_req() override;
  explicit constexpr Erk_EurekaBind_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_EurekaBind_req(const Erk_EurekaBind_req& from);
  Erk_EurekaBind_req(Erk_EurekaBind_req&& from) noexcept
    : Erk_EurekaBind_req() {
    *this = ::std::move(from);
  }

  inline Erk_EurekaBind_req& operator=(const Erk_EurekaBind_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_EurekaBind_req& operator=(Erk_EurekaBind_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_EurekaBind_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_EurekaBind_req* internal_default_instance() {
    return reinterpret_cast<const Erk_EurekaBind_req*>(
               &_Erk_EurekaBind_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Erk_EurekaBind_req& a, Erk_EurekaBind_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_EurekaBind_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_EurekaBind_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_EurekaBind_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_EurekaBind_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_EurekaBind_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_EurekaBind_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_EurekaBind_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_EurekaBind_req";
  }
  protected:
  explicit Erk_EurekaBind_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kIidFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPortFieldNumber = 4,
  };
  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int64 iid = 1;
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // int64 token = 2;
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // int32 port = 4;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_EurekaBind_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int64_t iid_;
  int64_t token_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_EurekaBind_ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_EurekaBind_ack) */ {
 public:
  inline Erk_EurekaBind_ack() : Erk_EurekaBind_ack(nullptr) {}
  ~Erk_EurekaBind_ack() override;
  explicit constexpr Erk_EurekaBind_ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_EurekaBind_ack(const Erk_EurekaBind_ack& from);
  Erk_EurekaBind_ack(Erk_EurekaBind_ack&& from) noexcept
    : Erk_EurekaBind_ack() {
    *this = ::std::move(from);
  }

  inline Erk_EurekaBind_ack& operator=(const Erk_EurekaBind_ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_EurekaBind_ack& operator=(Erk_EurekaBind_ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_EurekaBind_ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_EurekaBind_ack* internal_default_instance() {
    return reinterpret_cast<const Erk_EurekaBind_ack*>(
               &_Erk_EurekaBind_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Erk_EurekaBind_ack& a, Erk_EurekaBind_ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_EurekaBind_ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_EurekaBind_ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_EurekaBind_ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_EurekaBind_ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_EurekaBind_ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_EurekaBind_ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_EurekaBind_ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_EurekaBind_ack";
  }
  protected:
  explicit Erk_EurekaBind_ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_EurekaBind_ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_EurekaUpdate_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_EurekaUpdate_ntf) */ {
 public:
  inline Erk_EurekaUpdate_ntf() : Erk_EurekaUpdate_ntf(nullptr) {}
  ~Erk_EurekaUpdate_ntf() override;
  explicit constexpr Erk_EurekaUpdate_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_EurekaUpdate_ntf(const Erk_EurekaUpdate_ntf& from);
  Erk_EurekaUpdate_ntf(Erk_EurekaUpdate_ntf&& from) noexcept
    : Erk_EurekaUpdate_ntf() {
    *this = ::std::move(from);
  }

  inline Erk_EurekaUpdate_ntf& operator=(const Erk_EurekaUpdate_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_EurekaUpdate_ntf& operator=(Erk_EurekaUpdate_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_EurekaUpdate_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_EurekaUpdate_ntf* internal_default_instance() {
    return reinterpret_cast<const Erk_EurekaUpdate_ntf*>(
               &_Erk_EurekaUpdate_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Erk_EurekaUpdate_ntf& a, Erk_EurekaUpdate_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_EurekaUpdate_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_EurekaUpdate_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_EurekaUpdate_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_EurekaUpdate_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_EurekaUpdate_ntf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_EurekaUpdate_ntf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_EurekaUpdate_ntf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_EurekaUpdate_ntf";
  }
  protected:
  explicit Erk_EurekaUpdate_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnlineFieldNumber = 2,
    kOfflineFieldNumber = 3,
    kMyiidFieldNumber = 1,
  };
  // repeated .PRO.EurekaServerNode online = 2;
  int online_size() const;
  private:
  int _internal_online_size() const;
  public:
  void clear_online();
  ::PRO::EurekaServerNode* mutable_online(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::EurekaServerNode >*
      mutable_online();
  private:
  const ::PRO::EurekaServerNode& _internal_online(int index) const;
  ::PRO::EurekaServerNode* _internal_add_online();
  public:
  const ::PRO::EurekaServerNode& online(int index) const;
  ::PRO::EurekaServerNode* add_online();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::EurekaServerNode >&
      online() const;

  // repeated int64 offline = 3;
  int offline_size() const;
  private:
  int _internal_offline_size() const;
  public:
  void clear_offline();
  private:
  int64_t _internal_offline(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_offline() const;
  void _internal_add_offline(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_offline();
  public:
  int64_t offline(int index) const;
  void set_offline(int index, int64_t value);
  void add_offline(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      offline() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_offline();

  // int64 myiid = 1;
  void clear_myiid();
  int64_t myiid() const;
  void set_myiid(int64_t value);
  private:
  int64_t _internal_myiid() const;
  void _internal_set_myiid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_EurekaUpdate_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::EurekaServerNode > online_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > offline_;
  mutable std::atomic<int> _offline_cached_byte_size_;
  int64_t myiid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_Eureka_sync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_Eureka_sync) */ {
 public:
  inline Erk_Eureka_sync() : Erk_Eureka_sync(nullptr) {}
  ~Erk_Eureka_sync() override;
  explicit constexpr Erk_Eureka_sync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_Eureka_sync(const Erk_Eureka_sync& from);
  Erk_Eureka_sync(Erk_Eureka_sync&& from) noexcept
    : Erk_Eureka_sync() {
    *this = ::std::move(from);
  }

  inline Erk_Eureka_sync& operator=(const Erk_Eureka_sync& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_Eureka_sync& operator=(Erk_Eureka_sync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_Eureka_sync& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_Eureka_sync* internal_default_instance() {
    return reinterpret_cast<const Erk_Eureka_sync*>(
               &_Erk_Eureka_sync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Erk_Eureka_sync& a, Erk_Eureka_sync& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_Eureka_sync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_Eureka_sync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_Eureka_sync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_Eureka_sync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_Eureka_sync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_Eureka_sync& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_Eureka_sync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_Eureka_sync";
  }
  protected:
  explicit Erk_Eureka_sync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExistsFieldNumber = 2,
    kMyiidFieldNumber = 1,
  };
  // repeated int64 exists = 2;
  int exists_size() const;
  private:
  int _internal_exists_size() const;
  public:
  void clear_exists();
  private:
  int64_t _internal_exists(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_exists() const;
  void _internal_add_exists(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_exists();
  public:
  int64_t exists(int index) const;
  void set_exists(int index, int64_t value);
  void add_exists(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      exists() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_exists();

  // int64 myiid = 1;
  void clear_myiid();
  int64_t myiid() const;
  void set_myiid(int64_t value);
  private:
  int64_t _internal_myiid() const;
  void _internal_set_myiid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_Eureka_sync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > exists_;
  mutable std::atomic<int> _exists_cached_byte_size_;
  int64_t myiid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class ServerNode_ExtsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServerNode_ExtsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServerNode_ExtsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ServerNode_ExtsEntry_DoNotUse();
  explicit constexpr ServerNode_ExtsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServerNode_ExtsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServerNode_ExtsEntry_DoNotUse& other);
  static const ServerNode_ExtsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServerNode_ExtsEntry_DoNotUse*>(&_ServerNode_ExtsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.ServerNode.ExtsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.ServerNode.ExtsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ServerNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.ServerNode) */ {
 public:
  inline ServerNode() : ServerNode(nullptr) {}
  ~ServerNode() override;
  explicit constexpr ServerNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerNode(const ServerNode& from);
  ServerNode(ServerNode&& from) noexcept
    : ServerNode() {
    *this = ::std::move(from);
  }

  inline ServerNode& operator=(const ServerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerNode& operator=(ServerNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerNode* internal_default_instance() {
    return reinterpret_cast<const ServerNode*>(
               &_ServerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerNode& a, ServerNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.ServerNode";
  }
  protected:
  explicit ServerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtsFieldNumber = 5,
    kIpFieldNumber = 3,
    kIidFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPortFieldNumber = 4,
  };
  // map<string, string> exts = 5;
  int exts_size() const;
  private:
  int _internal_exts_size() const;
  public:
  void clear_exts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_exts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_exts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      exts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_exts();

  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int64 iid = 1;
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // int64 token = 2;
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // int32 port = 4;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.ServerNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ServerNode_ExtsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> exts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int64_t iid_;
  int64_t token_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceRegist_req_ExtsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Erk_ServiceRegist_req_ExtsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Erk_ServiceRegist_req_ExtsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Erk_ServiceRegist_req_ExtsEntry_DoNotUse();
  explicit constexpr Erk_ServiceRegist_req_ExtsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Erk_ServiceRegist_req_ExtsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Erk_ServiceRegist_req_ExtsEntry_DoNotUse& other);
  static const Erk_ServiceRegist_req_ExtsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Erk_ServiceRegist_req_ExtsEntry_DoNotUse*>(&_Erk_ServiceRegist_req_ExtsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.Erk_ServiceRegist_req.ExtsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.Erk_ServiceRegist_req.ExtsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Erk_ServiceRegist_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceRegist_req) */ {
 public:
  inline Erk_ServiceRegist_req() : Erk_ServiceRegist_req(nullptr) {}
  ~Erk_ServiceRegist_req() override;
  explicit constexpr Erk_ServiceRegist_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceRegist_req(const Erk_ServiceRegist_req& from);
  Erk_ServiceRegist_req(Erk_ServiceRegist_req&& from) noexcept
    : Erk_ServiceRegist_req() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceRegist_req& operator=(const Erk_ServiceRegist_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceRegist_req& operator=(Erk_ServiceRegist_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceRegist_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceRegist_req* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceRegist_req*>(
               &_Erk_ServiceRegist_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Erk_ServiceRegist_req& a, Erk_ServiceRegist_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceRegist_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceRegist_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceRegist_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceRegist_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceRegist_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceRegist_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceRegist_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceRegist_req";
  }
  protected:
  explicit Erk_ServiceRegist_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtsFieldNumber = 4,
    kIpFieldNumber = 2,
    kSvrTypeFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // map<string, string> exts = 4;
  int exts_size() const;
  private:
  int _internal_exts_size() const;
  public:
  void clear_exts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_exts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_exts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      exts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_exts();

  // string ip = 2;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 svr_type = 1;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // int32 port = 3;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceRegist_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Erk_ServiceRegist_req_ExtsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> exts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  int32_t svr_type_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceRegist_ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceRegist_ack) */ {
 public:
  inline Erk_ServiceRegist_ack() : Erk_ServiceRegist_ack(nullptr) {}
  ~Erk_ServiceRegist_ack() override;
  explicit constexpr Erk_ServiceRegist_ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceRegist_ack(const Erk_ServiceRegist_ack& from);
  Erk_ServiceRegist_ack(Erk_ServiceRegist_ack&& from) noexcept
    : Erk_ServiceRegist_ack() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceRegist_ack& operator=(const Erk_ServiceRegist_ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceRegist_ack& operator=(Erk_ServiceRegist_ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceRegist_ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceRegist_ack* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceRegist_ack*>(
               &_Erk_ServiceRegist_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Erk_ServiceRegist_ack& a, Erk_ServiceRegist_ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceRegist_ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceRegist_ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceRegist_ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceRegist_ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceRegist_ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceRegist_ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceRegist_ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceRegist_ack";
  }
  protected:
  explicit Erk_ServiceRegist_ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIidFieldNumber = 2,
    kTokenFieldNumber = 3,
    kEurekaiidFieldNumber = 4,
    kEurekatokenFieldNumber = 5,
    kResultFieldNumber = 1,
  };
  // optional int64 iid = 2;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // optional int64 token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // optional int64 eurekaiid = 4;
  bool has_eurekaiid() const;
  private:
  bool _internal_has_eurekaiid() const;
  public:
  void clear_eurekaiid();
  int64_t eurekaiid() const;
  void set_eurekaiid(int64_t value);
  private:
  int64_t _internal_eurekaiid() const;
  void _internal_set_eurekaiid(int64_t value);
  public:

  // optional int64 eurekatoken = 5;
  bool has_eurekatoken() const;
  private:
  bool _internal_has_eurekatoken() const;
  public:
  void clear_eurekatoken();
  int64_t eurekatoken() const;
  void set_eurekatoken(int64_t value);
  private:
  int64_t _internal_eurekatoken() const;
  void _internal_set_eurekatoken(int64_t value);
  public:

  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceRegist_ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t iid_;
  int64_t token_;
  int64_t eurekaiid_;
  int64_t eurekatoken_;
  int32_t result_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceRegist_Confirm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceRegist_Confirm) */ {
 public:
  inline Erk_ServiceRegist_Confirm() : Erk_ServiceRegist_Confirm(nullptr) {}
  ~Erk_ServiceRegist_Confirm() override;
  explicit constexpr Erk_ServiceRegist_Confirm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceRegist_Confirm(const Erk_ServiceRegist_Confirm& from);
  Erk_ServiceRegist_Confirm(Erk_ServiceRegist_Confirm&& from) noexcept
    : Erk_ServiceRegist_Confirm() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceRegist_Confirm& operator=(const Erk_ServiceRegist_Confirm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceRegist_Confirm& operator=(Erk_ServiceRegist_Confirm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceRegist_Confirm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceRegist_Confirm* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceRegist_Confirm*>(
               &_Erk_ServiceRegist_Confirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Erk_ServiceRegist_Confirm& a, Erk_ServiceRegist_Confirm& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceRegist_Confirm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceRegist_Confirm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceRegist_Confirm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceRegist_Confirm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceRegist_Confirm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceRegist_Confirm& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceRegist_Confirm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceRegist_Confirm";
  }
  protected:
  explicit Erk_ServiceRegist_Confirm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIidFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // int64 iid = 1;
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // int64 token = 2;
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceRegist_Confirm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t iid_;
  int64_t token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceBind_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceBind_req) */ {
 public:
  inline Erk_ServiceBind_req() : Erk_ServiceBind_req(nullptr) {}
  ~Erk_ServiceBind_req() override;
  explicit constexpr Erk_ServiceBind_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceBind_req(const Erk_ServiceBind_req& from);
  Erk_ServiceBind_req(Erk_ServiceBind_req&& from) noexcept
    : Erk_ServiceBind_req() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceBind_req& operator=(const Erk_ServiceBind_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceBind_req& operator=(Erk_ServiceBind_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceBind_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceBind_req* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceBind_req*>(
               &_Erk_ServiceBind_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Erk_ServiceBind_req& a, Erk_ServiceBind_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceBind_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceBind_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceBind_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceBind_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceBind_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceBind_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceBind_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceBind_req";
  }
  protected:
  explicit Erk_ServiceBind_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIidFieldNumber = 2,
    kTokenFieldNumber = 3,
    kSvrTypeFieldNumber = 1,
  };
  // int64 iid = 2;
  void clear_iid();
  int64_t iid() const;
  void set_iid(int64_t value);
  private:
  int64_t _internal_iid() const;
  void _internal_set_iid(int64_t value);
  public:

  // int64 token = 3;
  void clear_token();
  int64_t token() const;
  void set_token(int64_t value);
  private:
  int64_t _internal_token() const;
  void _internal_set_token(int64_t value);
  public:

  // int32 svr_type = 1;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceBind_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t iid_;
  int64_t token_;
  int32_t svr_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceBind_ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceBind_ack) */ {
 public:
  inline Erk_ServiceBind_ack() : Erk_ServiceBind_ack(nullptr) {}
  ~Erk_ServiceBind_ack() override;
  explicit constexpr Erk_ServiceBind_ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceBind_ack(const Erk_ServiceBind_ack& from);
  Erk_ServiceBind_ack(Erk_ServiceBind_ack&& from) noexcept
    : Erk_ServiceBind_ack() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceBind_ack& operator=(const Erk_ServiceBind_ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceBind_ack& operator=(Erk_ServiceBind_ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceBind_ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceBind_ack* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceBind_ack*>(
               &_Erk_ServiceBind_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Erk_ServiceBind_ack& a, Erk_ServiceBind_ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceBind_ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceBind_ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceBind_ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceBind_ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceBind_ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceBind_ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceBind_ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceBind_ack";
  }
  protected:
  explicit Erk_ServiceBind_ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceBind_ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceSubscribe_req_svrinfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceSubscribe_req.svrinfo) */ {
 public:
  inline Erk_ServiceSubscribe_req_svrinfo() : Erk_ServiceSubscribe_req_svrinfo(nullptr) {}
  ~Erk_ServiceSubscribe_req_svrinfo() override;
  explicit constexpr Erk_ServiceSubscribe_req_svrinfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceSubscribe_req_svrinfo(const Erk_ServiceSubscribe_req_svrinfo& from);
  Erk_ServiceSubscribe_req_svrinfo(Erk_ServiceSubscribe_req_svrinfo&& from) noexcept
    : Erk_ServiceSubscribe_req_svrinfo() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceSubscribe_req_svrinfo& operator=(const Erk_ServiceSubscribe_req_svrinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceSubscribe_req_svrinfo& operator=(Erk_ServiceSubscribe_req_svrinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceSubscribe_req_svrinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceSubscribe_req_svrinfo* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceSubscribe_req_svrinfo*>(
               &_Erk_ServiceSubscribe_req_svrinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Erk_ServiceSubscribe_req_svrinfo& a, Erk_ServiceSubscribe_req_svrinfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceSubscribe_req_svrinfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceSubscribe_req_svrinfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceSubscribe_req_svrinfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceSubscribe_req_svrinfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceSubscribe_req_svrinfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceSubscribe_req_svrinfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceSubscribe_req_svrinfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceSubscribe_req.svrinfo";
  }
  protected:
  explicit Erk_ServiceSubscribe_req_svrinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExitsFieldNumber = 2,
    kSvrTypeFieldNumber = 1,
  };
  // repeated int64 exits = 2;
  int exits_size() const;
  private:
  int _internal_exits_size() const;
  public:
  void clear_exits();
  private:
  int64_t _internal_exits(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_exits() const;
  void _internal_add_exits(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_exits();
  public:
  int64_t exits(int index) const;
  void set_exits(int index, int64_t value);
  void add_exits(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      exits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_exits();

  // int32 svr_type = 1;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceSubscribe_req.svrinfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > exits_;
  mutable std::atomic<int> _exits_cached_byte_size_;
  int32_t svr_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceSubscribe_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceSubscribe_req) */ {
 public:
  inline Erk_ServiceSubscribe_req() : Erk_ServiceSubscribe_req(nullptr) {}
  ~Erk_ServiceSubscribe_req() override;
  explicit constexpr Erk_ServiceSubscribe_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceSubscribe_req(const Erk_ServiceSubscribe_req& from);
  Erk_ServiceSubscribe_req(Erk_ServiceSubscribe_req&& from) noexcept
    : Erk_ServiceSubscribe_req() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceSubscribe_req& operator=(const Erk_ServiceSubscribe_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceSubscribe_req& operator=(Erk_ServiceSubscribe_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceSubscribe_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceSubscribe_req* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceSubscribe_req*>(
               &_Erk_ServiceSubscribe_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Erk_ServiceSubscribe_req& a, Erk_ServiceSubscribe_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceSubscribe_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceSubscribe_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceSubscribe_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceSubscribe_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceSubscribe_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceSubscribe_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceSubscribe_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceSubscribe_req";
  }
  protected:
  explicit Erk_ServiceSubscribe_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Erk_ServiceSubscribe_req_svrinfo svrinfo;

  // accessors -------------------------------------------------------

  enum : int {
    kSvrTypeFieldNumber = 5,
    kMyipFieldNumber = 3,
    kMyiidFieldNumber = 1,
    kMysvrtypeFieldNumber = 2,
    kMyportFieldNumber = 4,
  };
  // repeated .PRO.Erk_ServiceSubscribe_req.svrinfo svr_type = 5;
  int svr_type_size() const;
  private:
  int _internal_svr_type_size() const;
  public:
  void clear_svr_type();
  ::PRO::Erk_ServiceSubscribe_req_svrinfo* mutable_svr_type(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Erk_ServiceSubscribe_req_svrinfo >*
      mutable_svr_type();
  private:
  const ::PRO::Erk_ServiceSubscribe_req_svrinfo& _internal_svr_type(int index) const;
  ::PRO::Erk_ServiceSubscribe_req_svrinfo* _internal_add_svr_type();
  public:
  const ::PRO::Erk_ServiceSubscribe_req_svrinfo& svr_type(int index) const;
  ::PRO::Erk_ServiceSubscribe_req_svrinfo* add_svr_type();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Erk_ServiceSubscribe_req_svrinfo >&
      svr_type() const;

  // string myip = 3;
  void clear_myip();
  const std::string& myip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_myip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_myip();
  PROTOBUF_NODISCARD std::string* release_myip();
  void set_allocated_myip(std::string* myip);
  private:
  const std::string& _internal_myip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_myip(const std::string& value);
  std::string* _internal_mutable_myip();
  public:

  // int64 myiid = 1;
  void clear_myiid();
  int64_t myiid() const;
  void set_myiid(int64_t value);
  private:
  int64_t _internal_myiid() const;
  void _internal_set_myiid(int64_t value);
  public:

  // int32 mysvrtype = 2;
  void clear_mysvrtype();
  int32_t mysvrtype() const;
  void set_mysvrtype(int32_t value);
  private:
  int32_t _internal_mysvrtype() const;
  void _internal_set_mysvrtype(int32_t value);
  public:

  // int32 myport = 4;
  void clear_myport();
  int32_t myport() const;
  void set_myport(int32_t value);
  private:
  int32_t _internal_myport() const;
  void _internal_set_myport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceSubscribe_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Erk_ServiceSubscribe_req_svrinfo > svr_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr myip_;
  int64_t myiid_;
  int32_t mysvrtype_;
  int32_t myport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceSubscribe_ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceSubscribe_ack) */ {
 public:
  inline Erk_ServiceSubscribe_ack() : Erk_ServiceSubscribe_ack(nullptr) {}
  ~Erk_ServiceSubscribe_ack() override;
  explicit constexpr Erk_ServiceSubscribe_ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceSubscribe_ack(const Erk_ServiceSubscribe_ack& from);
  Erk_ServiceSubscribe_ack(Erk_ServiceSubscribe_ack&& from) noexcept
    : Erk_ServiceSubscribe_ack() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceSubscribe_ack& operator=(const Erk_ServiceSubscribe_ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceSubscribe_ack& operator=(Erk_ServiceSubscribe_ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceSubscribe_ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceSubscribe_ack* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceSubscribe_ack*>(
               &_Erk_ServiceSubscribe_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Erk_ServiceSubscribe_ack& a, Erk_ServiceSubscribe_ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceSubscribe_ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceSubscribe_ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceSubscribe_ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceSubscribe_ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceSubscribe_ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceSubscribe_ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceSubscribe_ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceSubscribe_ack";
  }
  protected:
  explicit Erk_ServiceSubscribe_ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnlineFieldNumber = 3,
    kOfflineFieldNumber = 4,
    kMyiidFieldNumber = 1,
    kSvrTypeFieldNumber = 2,
  };
  // repeated .PRO.ServerNode online = 3;
  int online_size() const;
  private:
  int _internal_online_size() const;
  public:
  void clear_online();
  ::PRO::ServerNode* mutable_online(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::ServerNode >*
      mutable_online();
  private:
  const ::PRO::ServerNode& _internal_online(int index) const;
  ::PRO::ServerNode* _internal_add_online();
  public:
  const ::PRO::ServerNode& online(int index) const;
  ::PRO::ServerNode* add_online();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::ServerNode >&
      online() const;

  // repeated int64 offline = 4;
  int offline_size() const;
  private:
  int _internal_offline_size() const;
  public:
  void clear_offline();
  private:
  int64_t _internal_offline(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_offline() const;
  void _internal_add_offline(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_offline();
  public:
  int64_t offline(int index) const;
  void set_offline(int index, int64_t value);
  void add_offline(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      offline() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_offline();

  // int64 myiid = 1;
  void clear_myiid();
  int64_t myiid() const;
  void set_myiid(int64_t value);
  private:
  int64_t _internal_myiid() const;
  void _internal_set_myiid(int64_t value);
  public:

  // int32 svr_type = 2;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceSubscribe_ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::ServerNode > online_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > offline_;
  mutable std::atomic<int> _offline_cached_byte_size_;
  int64_t myiid_;
  int32_t svr_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Erk_ServiceShutdown_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Erk_ServiceShutdown_ntf) */ {
 public:
  inline Erk_ServiceShutdown_ntf() : Erk_ServiceShutdown_ntf(nullptr) {}
  ~Erk_ServiceShutdown_ntf() override;
  explicit constexpr Erk_ServiceShutdown_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Erk_ServiceShutdown_ntf(const Erk_ServiceShutdown_ntf& from);
  Erk_ServiceShutdown_ntf(Erk_ServiceShutdown_ntf&& from) noexcept
    : Erk_ServiceShutdown_ntf() {
    *this = ::std::move(from);
  }

  inline Erk_ServiceShutdown_ntf& operator=(const Erk_ServiceShutdown_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Erk_ServiceShutdown_ntf& operator=(Erk_ServiceShutdown_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Erk_ServiceShutdown_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Erk_ServiceShutdown_ntf* internal_default_instance() {
    return reinterpret_cast<const Erk_ServiceShutdown_ntf*>(
               &_Erk_ServiceShutdown_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Erk_ServiceShutdown_ntf& a, Erk_ServiceShutdown_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Erk_ServiceShutdown_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Erk_ServiceShutdown_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Erk_ServiceShutdown_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Erk_ServiceShutdown_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Erk_ServiceShutdown_ntf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Erk_ServiceShutdown_ntf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Erk_ServiceShutdown_ntf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Erk_ServiceShutdown_ntf";
  }
  protected:
  explicit Erk_ServiceShutdown_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 2,
    kSvrTypeFieldNumber = 1,
  };
  // int64 service = 2;
  void clear_service();
  int64_t service() const;
  void set_service(int64_t value);
  private:
  int64_t _internal_service() const;
  void _internal_set_service(int64_t value);
  public:

  // int32 svr_type = 1;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Erk_ServiceShutdown_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t service_;
  int32_t svr_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Svr_LiveTick_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PRO.Svr_LiveTick_ntf) */ {
 public:
  inline Svr_LiveTick_ntf() : Svr_LiveTick_ntf(nullptr) {}
  explicit constexpr Svr_LiveTick_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Svr_LiveTick_ntf(const Svr_LiveTick_ntf& from);
  Svr_LiveTick_ntf(Svr_LiveTick_ntf&& from) noexcept
    : Svr_LiveTick_ntf() {
    *this = ::std::move(from);
  }

  inline Svr_LiveTick_ntf& operator=(const Svr_LiveTick_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Svr_LiveTick_ntf& operator=(Svr_LiveTick_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Svr_LiveTick_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Svr_LiveTick_ntf* internal_default_instance() {
    return reinterpret_cast<const Svr_LiveTick_ntf*>(
               &_Svr_LiveTick_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Svr_LiveTick_ntf& a, Svr_LiveTick_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Svr_LiveTick_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Svr_LiveTick_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Svr_LiveTick_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Svr_LiveTick_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Svr_LiveTick_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Svr_LiveTick_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Svr_LiveTick_ntf";
  }
  protected:
  explicit Svr_LiveTick_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PRO.Svr_LiveTick_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Svr_ServiceBindService_req_MyextsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Svr_ServiceBindService_req_MyextsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Svr_ServiceBindService_req_MyextsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Svr_ServiceBindService_req_MyextsEntry_DoNotUse();
  explicit constexpr Svr_ServiceBindService_req_MyextsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Svr_ServiceBindService_req_MyextsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Svr_ServiceBindService_req_MyextsEntry_DoNotUse& other);
  static const Svr_ServiceBindService_req_MyextsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Svr_ServiceBindService_req_MyextsEntry_DoNotUse*>(&_Svr_ServiceBindService_req_MyextsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.Svr_ServiceBindService_req.MyextsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "PRO.Svr_ServiceBindService_req.MyextsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Svr_ServiceBindService_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Svr_ServiceBindService_req) */ {
 public:
  inline Svr_ServiceBindService_req() : Svr_ServiceBindService_req(nullptr) {}
  ~Svr_ServiceBindService_req() override;
  explicit constexpr Svr_ServiceBindService_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Svr_ServiceBindService_req(const Svr_ServiceBindService_req& from);
  Svr_ServiceBindService_req(Svr_ServiceBindService_req&& from) noexcept
    : Svr_ServiceBindService_req() {
    *this = ::std::move(from);
  }

  inline Svr_ServiceBindService_req& operator=(const Svr_ServiceBindService_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Svr_ServiceBindService_req& operator=(Svr_ServiceBindService_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Svr_ServiceBindService_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Svr_ServiceBindService_req* internal_default_instance() {
    return reinterpret_cast<const Svr_ServiceBindService_req*>(
               &_Svr_ServiceBindService_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Svr_ServiceBindService_req& a, Svr_ServiceBindService_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Svr_ServiceBindService_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Svr_ServiceBindService_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Svr_ServiceBindService_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Svr_ServiceBindService_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Svr_ServiceBindService_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Svr_ServiceBindService_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Svr_ServiceBindService_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Svr_ServiceBindService_req";
  }
  protected:
  explicit Svr_ServiceBindService_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMyextsFieldNumber = 4,
    kMyiidFieldNumber = 2,
    kMytokenFieldNumber = 3,
    kSvrTypeFieldNumber = 1,
    kToiidFieldNumber = 10,
    kTotokenFieldNumber = 11,
  };
  // map<string, string> myexts = 4;
  int myexts_size() const;
  private:
  int _internal_myexts_size() const;
  public:
  void clear_myexts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_myexts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_myexts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      myexts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_myexts();

  // int64 myiid = 2;
  void clear_myiid();
  int64_t myiid() const;
  void set_myiid(int64_t value);
  private:
  int64_t _internal_myiid() const;
  void _internal_set_myiid(int64_t value);
  public:

  // int64 mytoken = 3;
  void clear_mytoken();
  int64_t mytoken() const;
  void set_mytoken(int64_t value);
  private:
  int64_t _internal_mytoken() const;
  void _internal_set_mytoken(int64_t value);
  public:

  // int32 svr_type = 1;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // int64 toiid = 10;
  void clear_toiid();
  int64_t toiid() const;
  void set_toiid(int64_t value);
  private:
  int64_t _internal_toiid() const;
  void _internal_set_toiid(int64_t value);
  public:

  // int64 totoken = 11;
  void clear_totoken();
  int64_t totoken() const;
  void set_totoken(int64_t value);
  private:
  int64_t _internal_totoken() const;
  void _internal_set_totoken(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Svr_ServiceBindService_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Svr_ServiceBindService_req_MyextsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> myexts_;
  int64_t myiid_;
  int64_t mytoken_;
  int32_t svr_type_;
  int64_t toiid_;
  int64_t totoken_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Svr_ServiceBindService_ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Svr_ServiceBindService_ack) */ {
 public:
  inline Svr_ServiceBindService_ack() : Svr_ServiceBindService_ack(nullptr) {}
  ~Svr_ServiceBindService_ack() override;
  explicit constexpr Svr_ServiceBindService_ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Svr_ServiceBindService_ack(const Svr_ServiceBindService_ack& from);
  Svr_ServiceBindService_ack(Svr_ServiceBindService_ack&& from) noexcept
    : Svr_ServiceBindService_ack() {
    *this = ::std::move(from);
  }

  inline Svr_ServiceBindService_ack& operator=(const Svr_ServiceBindService_ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Svr_ServiceBindService_ack& operator=(Svr_ServiceBindService_ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Svr_ServiceBindService_ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Svr_ServiceBindService_ack* internal_default_instance() {
    return reinterpret_cast<const Svr_ServiceBindService_ack*>(
               &_Svr_ServiceBindService_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Svr_ServiceBindService_ack& a, Svr_ServiceBindService_ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Svr_ServiceBindService_ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Svr_ServiceBindService_ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Svr_ServiceBindService_ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Svr_ServiceBindService_ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Svr_ServiceBindService_ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Svr_ServiceBindService_ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Svr_ServiceBindService_ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Svr_ServiceBindService_ack";
  }
  protected:
  explicit Svr_ServiceBindService_ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kSvrTypeFieldNumber = 2,
    kToiidFieldNumber = 3,
    kTotokenFieldNumber = 4,
  };
  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // int32 svr_type = 2;
  void clear_svr_type();
  int32_t svr_type() const;
  void set_svr_type(int32_t value);
  private:
  int32_t _internal_svr_type() const;
  void _internal_set_svr_type(int32_t value);
  public:

  // int64 toiid = 3;
  void clear_toiid();
  int64_t toiid() const;
  void set_toiid(int64_t value);
  private:
  int64_t _internal_toiid() const;
  void _internal_set_toiid(int64_t value);
  public:

  // int64 totoken = 4;
  void clear_totoken();
  int64_t totoken() const;
  void set_totoken(int64_t value);
  private:
  int64_t _internal_totoken() const;
  void _internal_set_totoken(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Svr_ServiceBindService_ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t result_;
  int32_t svr_type_;
  int64_t toiid_;
  int64_t totoken_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_eureka_5finternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EurekaServerNode

// int64 iid = 1;
inline void EurekaServerNode::clear_iid() {
  iid_ = int64_t{0};
}
inline int64_t EurekaServerNode::_internal_iid() const {
  return iid_;
}
inline int64_t EurekaServerNode::iid() const {
  // @@protoc_insertion_point(field_get:PRO.EurekaServerNode.iid)
  return _internal_iid();
}
inline void EurekaServerNode::_internal_set_iid(int64_t value) {
  
  iid_ = value;
}
inline void EurekaServerNode::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.EurekaServerNode.iid)
}

// int64 token = 2;
inline void EurekaServerNode::clear_token() {
  token_ = int64_t{0};
}
inline int64_t EurekaServerNode::_internal_token() const {
  return token_;
}
inline int64_t EurekaServerNode::token() const {
  // @@protoc_insertion_point(field_get:PRO.EurekaServerNode.token)
  return _internal_token();
}
inline void EurekaServerNode::_internal_set_token(int64_t value) {
  
  token_ = value;
}
inline void EurekaServerNode::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.EurekaServerNode.token)
}

// string ip = 3;
inline void EurekaServerNode::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& EurekaServerNode::ip() const {
  // @@protoc_insertion_point(field_get:PRO.EurekaServerNode.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EurekaServerNode::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.EurekaServerNode.ip)
}
inline std::string* EurekaServerNode::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:PRO.EurekaServerNode.ip)
  return _s;
}
inline const std::string& EurekaServerNode::_internal_ip() const {
  return ip_.Get();
}
inline void EurekaServerNode::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EurekaServerNode::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EurekaServerNode::release_ip() {
  // @@protoc_insertion_point(field_release:PRO.EurekaServerNode.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EurekaServerNode::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.EurekaServerNode.ip)
}

// int32 port = 4;
inline void EurekaServerNode::clear_port() {
  port_ = 0;
}
inline int32_t EurekaServerNode::_internal_port() const {
  return port_;
}
inline int32_t EurekaServerNode::port() const {
  // @@protoc_insertion_point(field_get:PRO.EurekaServerNode.port)
  return _internal_port();
}
inline void EurekaServerNode::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void EurekaServerNode::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PRO.EurekaServerNode.port)
}

// -------------------------------------------------------------------

// Erk_EurekaBind_req

// int64 iid = 1;
inline void Erk_EurekaBind_req::clear_iid() {
  iid_ = int64_t{0};
}
inline int64_t Erk_EurekaBind_req::_internal_iid() const {
  return iid_;
}
inline int64_t Erk_EurekaBind_req::iid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaBind_req.iid)
  return _internal_iid();
}
inline void Erk_EurekaBind_req::_internal_set_iid(int64_t value) {
  
  iid_ = value;
}
inline void Erk_EurekaBind_req::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaBind_req.iid)
}

// int64 token = 2;
inline void Erk_EurekaBind_req::clear_token() {
  token_ = int64_t{0};
}
inline int64_t Erk_EurekaBind_req::_internal_token() const {
  return token_;
}
inline int64_t Erk_EurekaBind_req::token() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaBind_req.token)
  return _internal_token();
}
inline void Erk_EurekaBind_req::_internal_set_token(int64_t value) {
  
  token_ = value;
}
inline void Erk_EurekaBind_req::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaBind_req.token)
}

// string ip = 3;
inline void Erk_EurekaBind_req::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Erk_EurekaBind_req::ip() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaBind_req.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Erk_EurekaBind_req::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaBind_req.ip)
}
inline std::string* Erk_EurekaBind_req::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:PRO.Erk_EurekaBind_req.ip)
  return _s;
}
inline const std::string& Erk_EurekaBind_req::_internal_ip() const {
  return ip_.Get();
}
inline void Erk_EurekaBind_req::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Erk_EurekaBind_req::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Erk_EurekaBind_req::release_ip() {
  // @@protoc_insertion_point(field_release:PRO.Erk_EurekaBind_req.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Erk_EurekaBind_req::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Erk_EurekaBind_req.ip)
}

// int32 port = 4;
inline void Erk_EurekaBind_req::clear_port() {
  port_ = 0;
}
inline int32_t Erk_EurekaBind_req::_internal_port() const {
  return port_;
}
inline int32_t Erk_EurekaBind_req::port() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaBind_req.port)
  return _internal_port();
}
inline void Erk_EurekaBind_req::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void Erk_EurekaBind_req::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaBind_req.port)
}

// -------------------------------------------------------------------

// Erk_EurekaBind_ack

// int32 result = 1;
inline void Erk_EurekaBind_ack::clear_result() {
  result_ = 0;
}
inline int32_t Erk_EurekaBind_ack::_internal_result() const {
  return result_;
}
inline int32_t Erk_EurekaBind_ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaBind_ack.result)
  return _internal_result();
}
inline void Erk_EurekaBind_ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Erk_EurekaBind_ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaBind_ack.result)
}

// -------------------------------------------------------------------

// Erk_EurekaUpdate_ntf

// int64 myiid = 1;
inline void Erk_EurekaUpdate_ntf::clear_myiid() {
  myiid_ = int64_t{0};
}
inline int64_t Erk_EurekaUpdate_ntf::_internal_myiid() const {
  return myiid_;
}
inline int64_t Erk_EurekaUpdate_ntf::myiid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaUpdate_ntf.myiid)
  return _internal_myiid();
}
inline void Erk_EurekaUpdate_ntf::_internal_set_myiid(int64_t value) {
  
  myiid_ = value;
}
inline void Erk_EurekaUpdate_ntf::set_myiid(int64_t value) {
  _internal_set_myiid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaUpdate_ntf.myiid)
}

// repeated .PRO.EurekaServerNode online = 2;
inline int Erk_EurekaUpdate_ntf::_internal_online_size() const {
  return online_.size();
}
inline int Erk_EurekaUpdate_ntf::online_size() const {
  return _internal_online_size();
}
inline void Erk_EurekaUpdate_ntf::clear_online() {
  online_.Clear();
}
inline ::PRO::EurekaServerNode* Erk_EurekaUpdate_ntf::mutable_online(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Erk_EurekaUpdate_ntf.online)
  return online_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::EurekaServerNode >*
Erk_EurekaUpdate_ntf::mutable_online() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_EurekaUpdate_ntf.online)
  return &online_;
}
inline const ::PRO::EurekaServerNode& Erk_EurekaUpdate_ntf::_internal_online(int index) const {
  return online_.Get(index);
}
inline const ::PRO::EurekaServerNode& Erk_EurekaUpdate_ntf::online(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaUpdate_ntf.online)
  return _internal_online(index);
}
inline ::PRO::EurekaServerNode* Erk_EurekaUpdate_ntf::_internal_add_online() {
  return online_.Add();
}
inline ::PRO::EurekaServerNode* Erk_EurekaUpdate_ntf::add_online() {
  ::PRO::EurekaServerNode* _add = _internal_add_online();
  // @@protoc_insertion_point(field_add:PRO.Erk_EurekaUpdate_ntf.online)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::EurekaServerNode >&
Erk_EurekaUpdate_ntf::online() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_EurekaUpdate_ntf.online)
  return online_;
}

// repeated int64 offline = 3;
inline int Erk_EurekaUpdate_ntf::_internal_offline_size() const {
  return offline_.size();
}
inline int Erk_EurekaUpdate_ntf::offline_size() const {
  return _internal_offline_size();
}
inline void Erk_EurekaUpdate_ntf::clear_offline() {
  offline_.Clear();
}
inline int64_t Erk_EurekaUpdate_ntf::_internal_offline(int index) const {
  return offline_.Get(index);
}
inline int64_t Erk_EurekaUpdate_ntf::offline(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_EurekaUpdate_ntf.offline)
  return _internal_offline(index);
}
inline void Erk_EurekaUpdate_ntf::set_offline(int index, int64_t value) {
  offline_.Set(index, value);
  // @@protoc_insertion_point(field_set:PRO.Erk_EurekaUpdate_ntf.offline)
}
inline void Erk_EurekaUpdate_ntf::_internal_add_offline(int64_t value) {
  offline_.Add(value);
}
inline void Erk_EurekaUpdate_ntf::add_offline(int64_t value) {
  _internal_add_offline(value);
  // @@protoc_insertion_point(field_add:PRO.Erk_EurekaUpdate_ntf.offline)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_EurekaUpdate_ntf::_internal_offline() const {
  return offline_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_EurekaUpdate_ntf::offline() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_EurekaUpdate_ntf.offline)
  return _internal_offline();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_EurekaUpdate_ntf::_internal_mutable_offline() {
  return &offline_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_EurekaUpdate_ntf::mutable_offline() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_EurekaUpdate_ntf.offline)
  return _internal_mutable_offline();
}

// -------------------------------------------------------------------

// Erk_Eureka_sync

// int64 myiid = 1;
inline void Erk_Eureka_sync::clear_myiid() {
  myiid_ = int64_t{0};
}
inline int64_t Erk_Eureka_sync::_internal_myiid() const {
  return myiid_;
}
inline int64_t Erk_Eureka_sync::myiid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_Eureka_sync.myiid)
  return _internal_myiid();
}
inline void Erk_Eureka_sync::_internal_set_myiid(int64_t value) {
  
  myiid_ = value;
}
inline void Erk_Eureka_sync::set_myiid(int64_t value) {
  _internal_set_myiid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_Eureka_sync.myiid)
}

// repeated int64 exists = 2;
inline int Erk_Eureka_sync::_internal_exists_size() const {
  return exists_.size();
}
inline int Erk_Eureka_sync::exists_size() const {
  return _internal_exists_size();
}
inline void Erk_Eureka_sync::clear_exists() {
  exists_.Clear();
}
inline int64_t Erk_Eureka_sync::_internal_exists(int index) const {
  return exists_.Get(index);
}
inline int64_t Erk_Eureka_sync::exists(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_Eureka_sync.exists)
  return _internal_exists(index);
}
inline void Erk_Eureka_sync::set_exists(int index, int64_t value) {
  exists_.Set(index, value);
  // @@protoc_insertion_point(field_set:PRO.Erk_Eureka_sync.exists)
}
inline void Erk_Eureka_sync::_internal_add_exists(int64_t value) {
  exists_.Add(value);
}
inline void Erk_Eureka_sync::add_exists(int64_t value) {
  _internal_add_exists(value);
  // @@protoc_insertion_point(field_add:PRO.Erk_Eureka_sync.exists)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_Eureka_sync::_internal_exists() const {
  return exists_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_Eureka_sync::exists() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_Eureka_sync.exists)
  return _internal_exists();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_Eureka_sync::_internal_mutable_exists() {
  return &exists_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_Eureka_sync::mutable_exists() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_Eureka_sync.exists)
  return _internal_mutable_exists();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServerNode

// int64 iid = 1;
inline void ServerNode::clear_iid() {
  iid_ = int64_t{0};
}
inline int64_t ServerNode::_internal_iid() const {
  return iid_;
}
inline int64_t ServerNode::iid() const {
  // @@protoc_insertion_point(field_get:PRO.ServerNode.iid)
  return _internal_iid();
}
inline void ServerNode::_internal_set_iid(int64_t value) {
  
  iid_ = value;
}
inline void ServerNode::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.ServerNode.iid)
}

// int64 token = 2;
inline void ServerNode::clear_token() {
  token_ = int64_t{0};
}
inline int64_t ServerNode::_internal_token() const {
  return token_;
}
inline int64_t ServerNode::token() const {
  // @@protoc_insertion_point(field_get:PRO.ServerNode.token)
  return _internal_token();
}
inline void ServerNode::_internal_set_token(int64_t value) {
  
  token_ = value;
}
inline void ServerNode::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.ServerNode.token)
}

// string ip = 3;
inline void ServerNode::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& ServerNode::ip() const {
  // @@protoc_insertion_point(field_get:PRO.ServerNode.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerNode::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.ServerNode.ip)
}
inline std::string* ServerNode::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:PRO.ServerNode.ip)
  return _s;
}
inline const std::string& ServerNode::_internal_ip() const {
  return ip_.Get();
}
inline void ServerNode::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerNode::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerNode::release_ip() {
  // @@protoc_insertion_point(field_release:PRO.ServerNode.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerNode::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.ServerNode.ip)
}

// int32 port = 4;
inline void ServerNode::clear_port() {
  port_ = 0;
}
inline int32_t ServerNode::_internal_port() const {
  return port_;
}
inline int32_t ServerNode::port() const {
  // @@protoc_insertion_point(field_get:PRO.ServerNode.port)
  return _internal_port();
}
inline void ServerNode::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void ServerNode::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PRO.ServerNode.port)
}

// map<string, string> exts = 5;
inline int ServerNode::_internal_exts_size() const {
  return exts_.size();
}
inline int ServerNode::exts_size() const {
  return _internal_exts_size();
}
inline void ServerNode::clear_exts() {
  exts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServerNode::_internal_exts() const {
  return exts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ServerNode::exts() const {
  // @@protoc_insertion_point(field_map:PRO.ServerNode.exts)
  return _internal_exts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServerNode::_internal_mutable_exts() {
  return exts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ServerNode::mutable_exts() {
  // @@protoc_insertion_point(field_mutable_map:PRO.ServerNode.exts)
  return _internal_mutable_exts();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Erk_ServiceRegist_req

// int32 svr_type = 1;
inline void Erk_ServiceRegist_req::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Erk_ServiceRegist_req::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Erk_ServiceRegist_req::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_req.svr_type)
  return _internal_svr_type();
}
inline void Erk_ServiceRegist_req::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Erk_ServiceRegist_req::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_req.svr_type)
}

// string ip = 2;
inline void Erk_ServiceRegist_req::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& Erk_ServiceRegist_req::ip() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_req.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Erk_ServiceRegist_req::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_req.ip)
}
inline std::string* Erk_ServiceRegist_req::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:PRO.Erk_ServiceRegist_req.ip)
  return _s;
}
inline const std::string& Erk_ServiceRegist_req::_internal_ip() const {
  return ip_.Get();
}
inline void Erk_ServiceRegist_req::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Erk_ServiceRegist_req::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Erk_ServiceRegist_req::release_ip() {
  // @@protoc_insertion_point(field_release:PRO.Erk_ServiceRegist_req.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Erk_ServiceRegist_req::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Erk_ServiceRegist_req.ip)
}

// int32 port = 3;
inline void Erk_ServiceRegist_req::clear_port() {
  port_ = 0;
}
inline int32_t Erk_ServiceRegist_req::_internal_port() const {
  return port_;
}
inline int32_t Erk_ServiceRegist_req::port() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_req.port)
  return _internal_port();
}
inline void Erk_ServiceRegist_req::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void Erk_ServiceRegist_req::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_req.port)
}

// map<string, string> exts = 4;
inline int Erk_ServiceRegist_req::_internal_exts_size() const {
  return exts_.size();
}
inline int Erk_ServiceRegist_req::exts_size() const {
  return _internal_exts_size();
}
inline void Erk_ServiceRegist_req::clear_exts() {
  exts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Erk_ServiceRegist_req::_internal_exts() const {
  return exts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Erk_ServiceRegist_req::exts() const {
  // @@protoc_insertion_point(field_map:PRO.Erk_ServiceRegist_req.exts)
  return _internal_exts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Erk_ServiceRegist_req::_internal_mutable_exts() {
  return exts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Erk_ServiceRegist_req::mutable_exts() {
  // @@protoc_insertion_point(field_mutable_map:PRO.Erk_ServiceRegist_req.exts)
  return _internal_mutable_exts();
}

// -------------------------------------------------------------------

// Erk_ServiceRegist_ack

// int32 result = 1;
inline void Erk_ServiceRegist_ack::clear_result() {
  result_ = 0;
}
inline int32_t Erk_ServiceRegist_ack::_internal_result() const {
  return result_;
}
inline int32_t Erk_ServiceRegist_ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_ack.result)
  return _internal_result();
}
inline void Erk_ServiceRegist_ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Erk_ServiceRegist_ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_ack.result)
}

// optional int64 iid = 2;
inline bool Erk_ServiceRegist_ack::_internal_has_iid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Erk_ServiceRegist_ack::has_iid() const {
  return _internal_has_iid();
}
inline void Erk_ServiceRegist_ack::clear_iid() {
  iid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Erk_ServiceRegist_ack::_internal_iid() const {
  return iid_;
}
inline int64_t Erk_ServiceRegist_ack::iid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_ack.iid)
  return _internal_iid();
}
inline void Erk_ServiceRegist_ack::_internal_set_iid(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  iid_ = value;
}
inline void Erk_ServiceRegist_ack::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_ack.iid)
}

// optional int64 token = 3;
inline bool Erk_ServiceRegist_ack::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Erk_ServiceRegist_ack::has_token() const {
  return _internal_has_token();
}
inline void Erk_ServiceRegist_ack::clear_token() {
  token_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t Erk_ServiceRegist_ack::_internal_token() const {
  return token_;
}
inline int64_t Erk_ServiceRegist_ack::token() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_ack.token)
  return _internal_token();
}
inline void Erk_ServiceRegist_ack::_internal_set_token(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  token_ = value;
}
inline void Erk_ServiceRegist_ack::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_ack.token)
}

// optional int64 eurekaiid = 4;
inline bool Erk_ServiceRegist_ack::_internal_has_eurekaiid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Erk_ServiceRegist_ack::has_eurekaiid() const {
  return _internal_has_eurekaiid();
}
inline void Erk_ServiceRegist_ack::clear_eurekaiid() {
  eurekaiid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t Erk_ServiceRegist_ack::_internal_eurekaiid() const {
  return eurekaiid_;
}
inline int64_t Erk_ServiceRegist_ack::eurekaiid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_ack.eurekaiid)
  return _internal_eurekaiid();
}
inline void Erk_ServiceRegist_ack::_internal_set_eurekaiid(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  eurekaiid_ = value;
}
inline void Erk_ServiceRegist_ack::set_eurekaiid(int64_t value) {
  _internal_set_eurekaiid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_ack.eurekaiid)
}

// optional int64 eurekatoken = 5;
inline bool Erk_ServiceRegist_ack::_internal_has_eurekatoken() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Erk_ServiceRegist_ack::has_eurekatoken() const {
  return _internal_has_eurekatoken();
}
inline void Erk_ServiceRegist_ack::clear_eurekatoken() {
  eurekatoken_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t Erk_ServiceRegist_ack::_internal_eurekatoken() const {
  return eurekatoken_;
}
inline int64_t Erk_ServiceRegist_ack::eurekatoken() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_ack.eurekatoken)
  return _internal_eurekatoken();
}
inline void Erk_ServiceRegist_ack::_internal_set_eurekatoken(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  eurekatoken_ = value;
}
inline void Erk_ServiceRegist_ack::set_eurekatoken(int64_t value) {
  _internal_set_eurekatoken(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_ack.eurekatoken)
}

// -------------------------------------------------------------------

// Erk_ServiceRegist_Confirm

// int64 iid = 1;
inline void Erk_ServiceRegist_Confirm::clear_iid() {
  iid_ = int64_t{0};
}
inline int64_t Erk_ServiceRegist_Confirm::_internal_iid() const {
  return iid_;
}
inline int64_t Erk_ServiceRegist_Confirm::iid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_Confirm.iid)
  return _internal_iid();
}
inline void Erk_ServiceRegist_Confirm::_internal_set_iid(int64_t value) {
  
  iid_ = value;
}
inline void Erk_ServiceRegist_Confirm::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_Confirm.iid)
}

// int64 token = 2;
inline void Erk_ServiceRegist_Confirm::clear_token() {
  token_ = int64_t{0};
}
inline int64_t Erk_ServiceRegist_Confirm::_internal_token() const {
  return token_;
}
inline int64_t Erk_ServiceRegist_Confirm::token() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceRegist_Confirm.token)
  return _internal_token();
}
inline void Erk_ServiceRegist_Confirm::_internal_set_token(int64_t value) {
  
  token_ = value;
}
inline void Erk_ServiceRegist_Confirm::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceRegist_Confirm.token)
}

// -------------------------------------------------------------------

// Erk_ServiceBind_req

// int32 svr_type = 1;
inline void Erk_ServiceBind_req::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Erk_ServiceBind_req::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Erk_ServiceBind_req::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceBind_req.svr_type)
  return _internal_svr_type();
}
inline void Erk_ServiceBind_req::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Erk_ServiceBind_req::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceBind_req.svr_type)
}

// int64 iid = 2;
inline void Erk_ServiceBind_req::clear_iid() {
  iid_ = int64_t{0};
}
inline int64_t Erk_ServiceBind_req::_internal_iid() const {
  return iid_;
}
inline int64_t Erk_ServiceBind_req::iid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceBind_req.iid)
  return _internal_iid();
}
inline void Erk_ServiceBind_req::_internal_set_iid(int64_t value) {
  
  iid_ = value;
}
inline void Erk_ServiceBind_req::set_iid(int64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceBind_req.iid)
}

// int64 token = 3;
inline void Erk_ServiceBind_req::clear_token() {
  token_ = int64_t{0};
}
inline int64_t Erk_ServiceBind_req::_internal_token() const {
  return token_;
}
inline int64_t Erk_ServiceBind_req::token() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceBind_req.token)
  return _internal_token();
}
inline void Erk_ServiceBind_req::_internal_set_token(int64_t value) {
  
  token_ = value;
}
inline void Erk_ServiceBind_req::set_token(int64_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceBind_req.token)
}

// -------------------------------------------------------------------

// Erk_ServiceBind_ack

// int32 result = 1;
inline void Erk_ServiceBind_ack::clear_result() {
  result_ = 0;
}
inline int32_t Erk_ServiceBind_ack::_internal_result() const {
  return result_;
}
inline int32_t Erk_ServiceBind_ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceBind_ack.result)
  return _internal_result();
}
inline void Erk_ServiceBind_ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Erk_ServiceBind_ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceBind_ack.result)
}

// -------------------------------------------------------------------

// Erk_ServiceSubscribe_req_svrinfo

// int32 svr_type = 1;
inline void Erk_ServiceSubscribe_req_svrinfo::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Erk_ServiceSubscribe_req_svrinfo::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Erk_ServiceSubscribe_req_svrinfo::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.svrinfo.svr_type)
  return _internal_svr_type();
}
inline void Erk_ServiceSubscribe_req_svrinfo::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Erk_ServiceSubscribe_req_svrinfo::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.svrinfo.svr_type)
}

// repeated int64 exits = 2;
inline int Erk_ServiceSubscribe_req_svrinfo::_internal_exits_size() const {
  return exits_.size();
}
inline int Erk_ServiceSubscribe_req_svrinfo::exits_size() const {
  return _internal_exits_size();
}
inline void Erk_ServiceSubscribe_req_svrinfo::clear_exits() {
  exits_.Clear();
}
inline int64_t Erk_ServiceSubscribe_req_svrinfo::_internal_exits(int index) const {
  return exits_.Get(index);
}
inline int64_t Erk_ServiceSubscribe_req_svrinfo::exits(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.svrinfo.exits)
  return _internal_exits(index);
}
inline void Erk_ServiceSubscribe_req_svrinfo::set_exits(int index, int64_t value) {
  exits_.Set(index, value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.svrinfo.exits)
}
inline void Erk_ServiceSubscribe_req_svrinfo::_internal_add_exits(int64_t value) {
  exits_.Add(value);
}
inline void Erk_ServiceSubscribe_req_svrinfo::add_exits(int64_t value) {
  _internal_add_exits(value);
  // @@protoc_insertion_point(field_add:PRO.Erk_ServiceSubscribe_req.svrinfo.exits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_ServiceSubscribe_req_svrinfo::_internal_exits() const {
  return exits_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_ServiceSubscribe_req_svrinfo::exits() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_ServiceSubscribe_req.svrinfo.exits)
  return _internal_exits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_ServiceSubscribe_req_svrinfo::_internal_mutable_exits() {
  return &exits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_ServiceSubscribe_req_svrinfo::mutable_exits() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_ServiceSubscribe_req.svrinfo.exits)
  return _internal_mutable_exits();
}

// -------------------------------------------------------------------

// Erk_ServiceSubscribe_req

// int64 myiid = 1;
inline void Erk_ServiceSubscribe_req::clear_myiid() {
  myiid_ = int64_t{0};
}
inline int64_t Erk_ServiceSubscribe_req::_internal_myiid() const {
  return myiid_;
}
inline int64_t Erk_ServiceSubscribe_req::myiid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.myiid)
  return _internal_myiid();
}
inline void Erk_ServiceSubscribe_req::_internal_set_myiid(int64_t value) {
  
  myiid_ = value;
}
inline void Erk_ServiceSubscribe_req::set_myiid(int64_t value) {
  _internal_set_myiid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.myiid)
}

// int32 mysvrtype = 2;
inline void Erk_ServiceSubscribe_req::clear_mysvrtype() {
  mysvrtype_ = 0;
}
inline int32_t Erk_ServiceSubscribe_req::_internal_mysvrtype() const {
  return mysvrtype_;
}
inline int32_t Erk_ServiceSubscribe_req::mysvrtype() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.mysvrtype)
  return _internal_mysvrtype();
}
inline void Erk_ServiceSubscribe_req::_internal_set_mysvrtype(int32_t value) {
  
  mysvrtype_ = value;
}
inline void Erk_ServiceSubscribe_req::set_mysvrtype(int32_t value) {
  _internal_set_mysvrtype(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.mysvrtype)
}

// string myip = 3;
inline void Erk_ServiceSubscribe_req::clear_myip() {
  myip_.ClearToEmpty();
}
inline const std::string& Erk_ServiceSubscribe_req::myip() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.myip)
  return _internal_myip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Erk_ServiceSubscribe_req::set_myip(ArgT0&& arg0, ArgT... args) {
 
 myip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.myip)
}
inline std::string* Erk_ServiceSubscribe_req::mutable_myip() {
  std::string* _s = _internal_mutable_myip();
  // @@protoc_insertion_point(field_mutable:PRO.Erk_ServiceSubscribe_req.myip)
  return _s;
}
inline const std::string& Erk_ServiceSubscribe_req::_internal_myip() const {
  return myip_.Get();
}
inline void Erk_ServiceSubscribe_req::_internal_set_myip(const std::string& value) {
  
  myip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Erk_ServiceSubscribe_req::_internal_mutable_myip() {
  
  return myip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Erk_ServiceSubscribe_req::release_myip() {
  // @@protoc_insertion_point(field_release:PRO.Erk_ServiceSubscribe_req.myip)
  return myip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Erk_ServiceSubscribe_req::set_allocated_myip(std::string* myip) {
  if (myip != nullptr) {
    
  } else {
    
  }
  myip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), myip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (myip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    myip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Erk_ServiceSubscribe_req.myip)
}

// int32 myport = 4;
inline void Erk_ServiceSubscribe_req::clear_myport() {
  myport_ = 0;
}
inline int32_t Erk_ServiceSubscribe_req::_internal_myport() const {
  return myport_;
}
inline int32_t Erk_ServiceSubscribe_req::myport() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.myport)
  return _internal_myport();
}
inline void Erk_ServiceSubscribe_req::_internal_set_myport(int32_t value) {
  
  myport_ = value;
}
inline void Erk_ServiceSubscribe_req::set_myport(int32_t value) {
  _internal_set_myport(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_req.myport)
}

// repeated .PRO.Erk_ServiceSubscribe_req.svrinfo svr_type = 5;
inline int Erk_ServiceSubscribe_req::_internal_svr_type_size() const {
  return svr_type_.size();
}
inline int Erk_ServiceSubscribe_req::svr_type_size() const {
  return _internal_svr_type_size();
}
inline void Erk_ServiceSubscribe_req::clear_svr_type() {
  svr_type_.Clear();
}
inline ::PRO::Erk_ServiceSubscribe_req_svrinfo* Erk_ServiceSubscribe_req::mutable_svr_type(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Erk_ServiceSubscribe_req.svr_type)
  return svr_type_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Erk_ServiceSubscribe_req_svrinfo >*
Erk_ServiceSubscribe_req::mutable_svr_type() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_ServiceSubscribe_req.svr_type)
  return &svr_type_;
}
inline const ::PRO::Erk_ServiceSubscribe_req_svrinfo& Erk_ServiceSubscribe_req::_internal_svr_type(int index) const {
  return svr_type_.Get(index);
}
inline const ::PRO::Erk_ServiceSubscribe_req_svrinfo& Erk_ServiceSubscribe_req::svr_type(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_req.svr_type)
  return _internal_svr_type(index);
}
inline ::PRO::Erk_ServiceSubscribe_req_svrinfo* Erk_ServiceSubscribe_req::_internal_add_svr_type() {
  return svr_type_.Add();
}
inline ::PRO::Erk_ServiceSubscribe_req_svrinfo* Erk_ServiceSubscribe_req::add_svr_type() {
  ::PRO::Erk_ServiceSubscribe_req_svrinfo* _add = _internal_add_svr_type();
  // @@protoc_insertion_point(field_add:PRO.Erk_ServiceSubscribe_req.svr_type)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Erk_ServiceSubscribe_req_svrinfo >&
Erk_ServiceSubscribe_req::svr_type() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_ServiceSubscribe_req.svr_type)
  return svr_type_;
}

// -------------------------------------------------------------------

// Erk_ServiceSubscribe_ack

// int64 myiid = 1;
inline void Erk_ServiceSubscribe_ack::clear_myiid() {
  myiid_ = int64_t{0};
}
inline int64_t Erk_ServiceSubscribe_ack::_internal_myiid() const {
  return myiid_;
}
inline int64_t Erk_ServiceSubscribe_ack::myiid() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_ack.myiid)
  return _internal_myiid();
}
inline void Erk_ServiceSubscribe_ack::_internal_set_myiid(int64_t value) {
  
  myiid_ = value;
}
inline void Erk_ServiceSubscribe_ack::set_myiid(int64_t value) {
  _internal_set_myiid(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_ack.myiid)
}

// int32 svr_type = 2;
inline void Erk_ServiceSubscribe_ack::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Erk_ServiceSubscribe_ack::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Erk_ServiceSubscribe_ack::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_ack.svr_type)
  return _internal_svr_type();
}
inline void Erk_ServiceSubscribe_ack::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Erk_ServiceSubscribe_ack::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_ack.svr_type)
}

// repeated .PRO.ServerNode online = 3;
inline int Erk_ServiceSubscribe_ack::_internal_online_size() const {
  return online_.size();
}
inline int Erk_ServiceSubscribe_ack::online_size() const {
  return _internal_online_size();
}
inline void Erk_ServiceSubscribe_ack::clear_online() {
  online_.Clear();
}
inline ::PRO::ServerNode* Erk_ServiceSubscribe_ack::mutable_online(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Erk_ServiceSubscribe_ack.online)
  return online_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::ServerNode >*
Erk_ServiceSubscribe_ack::mutable_online() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_ServiceSubscribe_ack.online)
  return &online_;
}
inline const ::PRO::ServerNode& Erk_ServiceSubscribe_ack::_internal_online(int index) const {
  return online_.Get(index);
}
inline const ::PRO::ServerNode& Erk_ServiceSubscribe_ack::online(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_ack.online)
  return _internal_online(index);
}
inline ::PRO::ServerNode* Erk_ServiceSubscribe_ack::_internal_add_online() {
  return online_.Add();
}
inline ::PRO::ServerNode* Erk_ServiceSubscribe_ack::add_online() {
  ::PRO::ServerNode* _add = _internal_add_online();
  // @@protoc_insertion_point(field_add:PRO.Erk_ServiceSubscribe_ack.online)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::ServerNode >&
Erk_ServiceSubscribe_ack::online() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_ServiceSubscribe_ack.online)
  return online_;
}

// repeated int64 offline = 4;
inline int Erk_ServiceSubscribe_ack::_internal_offline_size() const {
  return offline_.size();
}
inline int Erk_ServiceSubscribe_ack::offline_size() const {
  return _internal_offline_size();
}
inline void Erk_ServiceSubscribe_ack::clear_offline() {
  offline_.Clear();
}
inline int64_t Erk_ServiceSubscribe_ack::_internal_offline(int index) const {
  return offline_.Get(index);
}
inline int64_t Erk_ServiceSubscribe_ack::offline(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceSubscribe_ack.offline)
  return _internal_offline(index);
}
inline void Erk_ServiceSubscribe_ack::set_offline(int index, int64_t value) {
  offline_.Set(index, value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceSubscribe_ack.offline)
}
inline void Erk_ServiceSubscribe_ack::_internal_add_offline(int64_t value) {
  offline_.Add(value);
}
inline void Erk_ServiceSubscribe_ack::add_offline(int64_t value) {
  _internal_add_offline(value);
  // @@protoc_insertion_point(field_add:PRO.Erk_ServiceSubscribe_ack.offline)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_ServiceSubscribe_ack::_internal_offline() const {
  return offline_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Erk_ServiceSubscribe_ack::offline() const {
  // @@protoc_insertion_point(field_list:PRO.Erk_ServiceSubscribe_ack.offline)
  return _internal_offline();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_ServiceSubscribe_ack::_internal_mutable_offline() {
  return &offline_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Erk_ServiceSubscribe_ack::mutable_offline() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Erk_ServiceSubscribe_ack.offline)
  return _internal_mutable_offline();
}

// -------------------------------------------------------------------

// Erk_ServiceShutdown_ntf

// int32 svr_type = 1;
inline void Erk_ServiceShutdown_ntf::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Erk_ServiceShutdown_ntf::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Erk_ServiceShutdown_ntf::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceShutdown_ntf.svr_type)
  return _internal_svr_type();
}
inline void Erk_ServiceShutdown_ntf::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Erk_ServiceShutdown_ntf::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceShutdown_ntf.svr_type)
}

// int64 service = 2;
inline void Erk_ServiceShutdown_ntf::clear_service() {
  service_ = int64_t{0};
}
inline int64_t Erk_ServiceShutdown_ntf::_internal_service() const {
  return service_;
}
inline int64_t Erk_ServiceShutdown_ntf::service() const {
  // @@protoc_insertion_point(field_get:PRO.Erk_ServiceShutdown_ntf.service)
  return _internal_service();
}
inline void Erk_ServiceShutdown_ntf::_internal_set_service(int64_t value) {
  
  service_ = value;
}
inline void Erk_ServiceShutdown_ntf::set_service(int64_t value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:PRO.Erk_ServiceShutdown_ntf.service)
}

// -------------------------------------------------------------------

// Svr_LiveTick_ntf

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Svr_ServiceBindService_req

// int32 svr_type = 1;
inline void Svr_ServiceBindService_req::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Svr_ServiceBindService_req::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Svr_ServiceBindService_req::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_req.svr_type)
  return _internal_svr_type();
}
inline void Svr_ServiceBindService_req::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Svr_ServiceBindService_req::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_req.svr_type)
}

// int64 myiid = 2;
inline void Svr_ServiceBindService_req::clear_myiid() {
  myiid_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_req::_internal_myiid() const {
  return myiid_;
}
inline int64_t Svr_ServiceBindService_req::myiid() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_req.myiid)
  return _internal_myiid();
}
inline void Svr_ServiceBindService_req::_internal_set_myiid(int64_t value) {
  
  myiid_ = value;
}
inline void Svr_ServiceBindService_req::set_myiid(int64_t value) {
  _internal_set_myiid(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_req.myiid)
}

// int64 mytoken = 3;
inline void Svr_ServiceBindService_req::clear_mytoken() {
  mytoken_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_req::_internal_mytoken() const {
  return mytoken_;
}
inline int64_t Svr_ServiceBindService_req::mytoken() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_req.mytoken)
  return _internal_mytoken();
}
inline void Svr_ServiceBindService_req::_internal_set_mytoken(int64_t value) {
  
  mytoken_ = value;
}
inline void Svr_ServiceBindService_req::set_mytoken(int64_t value) {
  _internal_set_mytoken(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_req.mytoken)
}

// map<string, string> myexts = 4;
inline int Svr_ServiceBindService_req::_internal_myexts_size() const {
  return myexts_.size();
}
inline int Svr_ServiceBindService_req::myexts_size() const {
  return _internal_myexts_size();
}
inline void Svr_ServiceBindService_req::clear_myexts() {
  myexts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Svr_ServiceBindService_req::_internal_myexts() const {
  return myexts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Svr_ServiceBindService_req::myexts() const {
  // @@protoc_insertion_point(field_map:PRO.Svr_ServiceBindService_req.myexts)
  return _internal_myexts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Svr_ServiceBindService_req::_internal_mutable_myexts() {
  return myexts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Svr_ServiceBindService_req::mutable_myexts() {
  // @@protoc_insertion_point(field_mutable_map:PRO.Svr_ServiceBindService_req.myexts)
  return _internal_mutable_myexts();
}

// int64 toiid = 10;
inline void Svr_ServiceBindService_req::clear_toiid() {
  toiid_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_req::_internal_toiid() const {
  return toiid_;
}
inline int64_t Svr_ServiceBindService_req::toiid() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_req.toiid)
  return _internal_toiid();
}
inline void Svr_ServiceBindService_req::_internal_set_toiid(int64_t value) {
  
  toiid_ = value;
}
inline void Svr_ServiceBindService_req::set_toiid(int64_t value) {
  _internal_set_toiid(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_req.toiid)
}

// int64 totoken = 11;
inline void Svr_ServiceBindService_req::clear_totoken() {
  totoken_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_req::_internal_totoken() const {
  return totoken_;
}
inline int64_t Svr_ServiceBindService_req::totoken() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_req.totoken)
  return _internal_totoken();
}
inline void Svr_ServiceBindService_req::_internal_set_totoken(int64_t value) {
  
  totoken_ = value;
}
inline void Svr_ServiceBindService_req::set_totoken(int64_t value) {
  _internal_set_totoken(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_req.totoken)
}

// -------------------------------------------------------------------

// Svr_ServiceBindService_ack

// int32 result = 1;
inline void Svr_ServiceBindService_ack::clear_result() {
  result_ = 0;
}
inline int32_t Svr_ServiceBindService_ack::_internal_result() const {
  return result_;
}
inline int32_t Svr_ServiceBindService_ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_ack.result)
  return _internal_result();
}
inline void Svr_ServiceBindService_ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Svr_ServiceBindService_ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_ack.result)
}

// int32 svr_type = 2;
inline void Svr_ServiceBindService_ack::clear_svr_type() {
  svr_type_ = 0;
}
inline int32_t Svr_ServiceBindService_ack::_internal_svr_type() const {
  return svr_type_;
}
inline int32_t Svr_ServiceBindService_ack::svr_type() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_ack.svr_type)
  return _internal_svr_type();
}
inline void Svr_ServiceBindService_ack::_internal_set_svr_type(int32_t value) {
  
  svr_type_ = value;
}
inline void Svr_ServiceBindService_ack::set_svr_type(int32_t value) {
  _internal_set_svr_type(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_ack.svr_type)
}

// int64 toiid = 3;
inline void Svr_ServiceBindService_ack::clear_toiid() {
  toiid_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_ack::_internal_toiid() const {
  return toiid_;
}
inline int64_t Svr_ServiceBindService_ack::toiid() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_ack.toiid)
  return _internal_toiid();
}
inline void Svr_ServiceBindService_ack::_internal_set_toiid(int64_t value) {
  
  toiid_ = value;
}
inline void Svr_ServiceBindService_ack::set_toiid(int64_t value) {
  _internal_set_toiid(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_ack.toiid)
}

// int64 totoken = 4;
inline void Svr_ServiceBindService_ack::clear_totoken() {
  totoken_ = int64_t{0};
}
inline int64_t Svr_ServiceBindService_ack::_internal_totoken() const {
  return totoken_;
}
inline int64_t Svr_ServiceBindService_ack::totoken() const {
  // @@protoc_insertion_point(field_get:PRO.Svr_ServiceBindService_ack.totoken)
  return _internal_totoken();
}
inline void Svr_ServiceBindService_ack::_internal_set_totoken(int64_t value) {
  
  totoken_ = value;
}
inline void Svr_ServiceBindService_ack::set_totoken(int64_t value) {
  _internal_set_totoken(value);
  // @@protoc_insertion_point(field_set:PRO.Svr_ServiceBindService_ack.totoken)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PRO

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PRO::ERK_SERVICETYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRO::ERK_SERVICETYPE>() {
  return ::PRO::ERK_SERVICETYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_eureka_5finternal_2eproto
