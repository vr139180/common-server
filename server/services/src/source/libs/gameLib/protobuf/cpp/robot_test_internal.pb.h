// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_test_internal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_5ftest_5finternal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5ftest_5finternal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5ftest_5finternal_2eproto;
namespace PRO {
class Robot_ClearLogs_ntf;
struct Robot_ClearLogs_ntfDefaultTypeInternal;
extern Robot_ClearLogs_ntfDefaultTypeInternal _Robot_ClearLogs_ntf_default_instance_;
class Robot_Config_Ack;
struct Robot_Config_AckDefaultTypeInternal;
extern Robot_Config_AckDefaultTypeInternal _Robot_Config_Ack_default_instance_;
class Robot_Config_Req;
struct Robot_Config_ReqDefaultTypeInternal;
extern Robot_Config_ReqDefaultTypeInternal _Robot_Config_Req_default_instance_;
class Robot_EndRecord_req;
struct Robot_EndRecord_reqDefaultTypeInternal;
extern Robot_EndRecord_reqDefaultTypeInternal _Robot_EndRecord_req_default_instance_;
class Robot_Record_req;
struct Robot_Record_reqDefaultTypeInternal;
extern Robot_Record_reqDefaultTypeInternal _Robot_Record_req_default_instance_;
class Robot_StartRecord_req;
struct Robot_StartRecord_reqDefaultTypeInternal;
extern Robot_StartRecord_reqDefaultTypeInternal _Robot_StartRecord_req_default_instance_;
class Robot_Start_Ack;
struct Robot_Start_AckDefaultTypeInternal;
extern Robot_Start_AckDefaultTypeInternal _Robot_Start_Ack_default_instance_;
class Robot_Stop_Ack;
struct Robot_Stop_AckDefaultTypeInternal;
extern Robot_Stop_AckDefaultTypeInternal _Robot_Stop_Ack_default_instance_;
class Robot_UploadLogs_ntf;
struct Robot_UploadLogs_ntfDefaultTypeInternal;
extern Robot_UploadLogs_ntfDefaultTypeInternal _Robot_UploadLogs_ntf_default_instance_;
class Robot_UserPrefixChg_ntf;
struct Robot_UserPrefixChg_ntfDefaultTypeInternal;
extern Robot_UserPrefixChg_ntfDefaultTypeInternal _Robot_UserPrefixChg_ntf_default_instance_;
}  // namespace PRO
PROTOBUF_NAMESPACE_OPEN
template<> ::PRO::Robot_ClearLogs_ntf* Arena::CreateMaybeMessage<::PRO::Robot_ClearLogs_ntf>(Arena*);
template<> ::PRO::Robot_Config_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Config_Ack>(Arena*);
template<> ::PRO::Robot_Config_Req* Arena::CreateMaybeMessage<::PRO::Robot_Config_Req>(Arena*);
template<> ::PRO::Robot_EndRecord_req* Arena::CreateMaybeMessage<::PRO::Robot_EndRecord_req>(Arena*);
template<> ::PRO::Robot_Record_req* Arena::CreateMaybeMessage<::PRO::Robot_Record_req>(Arena*);
template<> ::PRO::Robot_StartRecord_req* Arena::CreateMaybeMessage<::PRO::Robot_StartRecord_req>(Arena*);
template<> ::PRO::Robot_Start_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Start_Ack>(Arena*);
template<> ::PRO::Robot_Stop_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Stop_Ack>(Arena*);
template<> ::PRO::Robot_UploadLogs_ntf* Arena::CreateMaybeMessage<::PRO::Robot_UploadLogs_ntf>(Arena*);
template<> ::PRO::Robot_UserPrefixChg_ntf* Arena::CreateMaybeMessage<::PRO::Robot_UserPrefixChg_ntf>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PRO {

enum ROBOT_CONST : int {
  ROBOT_CONST_UNIVERSAL = 0,
  ROBOT_VERSION = 1,
  ROBOT_CONST_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ROBOT_CONST_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ROBOT_CONST_IsValid(int value);
constexpr ROBOT_CONST ROBOT_CONST_MIN = ROBOT_CONST_UNIVERSAL;
constexpr ROBOT_CONST ROBOT_CONST_MAX = ROBOT_VERSION;
constexpr int ROBOT_CONST_ARRAYSIZE = ROBOT_CONST_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ROBOT_CONST_descriptor();
template<typename T>
inline const std::string& ROBOT_CONST_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ROBOT_CONST>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ROBOT_CONST_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ROBOT_CONST_descriptor(), enum_t_value);
}
inline bool ROBOT_CONST_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ROBOT_CONST* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ROBOT_CONST>(
    ROBOT_CONST_descriptor(), name, value);
}
// ===================================================================

class Robot_Config_Req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Config_Req) */ {
 public:
  inline Robot_Config_Req() : Robot_Config_Req(nullptr) {}
  ~Robot_Config_Req() override;
  explicit constexpr Robot_Config_Req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Config_Req(const Robot_Config_Req& from);
  Robot_Config_Req(Robot_Config_Req&& from) noexcept
    : Robot_Config_Req() {
    *this = ::std::move(from);
  }

  inline Robot_Config_Req& operator=(const Robot_Config_Req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Config_Req& operator=(Robot_Config_Req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Config_Req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Config_Req* internal_default_instance() {
    return reinterpret_cast<const Robot_Config_Req*>(
               &_Robot_Config_Req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot_Config_Req& a, Robot_Config_Req& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Config_Req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Config_Req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Config_Req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Config_Req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Config_Req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Config_Req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Config_Req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Config_Req";
  }
  protected:
  explicit Robot_Config_Req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotnameFieldNumber = 2,
    kRobotpwdFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // string robotname = 2;
  void clear_robotname();
  const std::string& robotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotname();
  PROTOBUF_NODISCARD std::string* release_robotname();
  void set_allocated_robotname(std::string* robotname);
  private:
  const std::string& _internal_robotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotname(const std::string& value);
  std::string* _internal_mutable_robotname();
  public:

  // string robotpwd = 3;
  void clear_robotpwd();
  const std::string& robotpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotpwd();
  PROTOBUF_NODISCARD std::string* release_robotpwd();
  void set_allocated_robotpwd(std::string* robotpwd);
  private:
  const std::string& _internal_robotpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotpwd(const std::string& value);
  std::string* _internal_mutable_robotpwd();
  public:

  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Config_Req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotpwd_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Config_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Config_Ack) */ {
 public:
  inline Robot_Config_Ack() : Robot_Config_Ack(nullptr) {}
  ~Robot_Config_Ack() override;
  explicit constexpr Robot_Config_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Config_Ack(const Robot_Config_Ack& from);
  Robot_Config_Ack(Robot_Config_Ack&& from) noexcept
    : Robot_Config_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Config_Ack& operator=(const Robot_Config_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Config_Ack& operator=(Robot_Config_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Config_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Config_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Config_Ack*>(
               &_Robot_Config_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Robot_Config_Ack& a, Robot_Config_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Config_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Config_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Config_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Config_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Config_Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Config_Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Config_Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Config_Ack";
  }
  protected:
  explicit Robot_Config_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrladdrFieldNumber = 4,
    kOpenprefixFieldNumber = 5,
    kDbuserFieldNumber = 10,
    kDbpwdFieldNumber = 11,
    kDbnameFieldNumber = 12,
    kDbipFieldNumber = 13,
    kVersionFieldNumber = 1,
    kResultFieldNumber = 2,
    kRobotidFieldNumber = 3,
    kUsersFieldNumber = 8,
    kStartuseridFieldNumber = 7,
  };
  // optional string urladdr = 4;
  bool has_urladdr() const;
  private:
  bool _internal_has_urladdr() const;
  public:
  void clear_urladdr();
  const std::string& urladdr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_urladdr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_urladdr();
  PROTOBUF_NODISCARD std::string* release_urladdr();
  void set_allocated_urladdr(std::string* urladdr);
  private:
  const std::string& _internal_urladdr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_urladdr(const std::string& value);
  std::string* _internal_mutable_urladdr();
  public:

  // optional string openprefix = 5;
  bool has_openprefix() const;
  private:
  bool _internal_has_openprefix() const;
  public:
  void clear_openprefix();
  const std::string& openprefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_openprefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_openprefix();
  PROTOBUF_NODISCARD std::string* release_openprefix();
  void set_allocated_openprefix(std::string* openprefix);
  private:
  const std::string& _internal_openprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_openprefix(const std::string& value);
  std::string* _internal_mutable_openprefix();
  public:

  // optional string dbuser = 10;
  bool has_dbuser() const;
  private:
  bool _internal_has_dbuser() const;
  public:
  void clear_dbuser();
  const std::string& dbuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbuser();
  PROTOBUF_NODISCARD std::string* release_dbuser();
  void set_allocated_dbuser(std::string* dbuser);
  private:
  const std::string& _internal_dbuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbuser(const std::string& value);
  std::string* _internal_mutable_dbuser();
  public:

  // optional string dbpwd = 11;
  bool has_dbpwd() const;
  private:
  bool _internal_has_dbpwd() const;
  public:
  void clear_dbpwd();
  const std::string& dbpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbpwd();
  PROTOBUF_NODISCARD std::string* release_dbpwd();
  void set_allocated_dbpwd(std::string* dbpwd);
  private:
  const std::string& _internal_dbpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbpwd(const std::string& value);
  std::string* _internal_mutable_dbpwd();
  public:

  // optional string dbname = 12;
  bool has_dbname() const;
  private:
  bool _internal_has_dbname() const;
  public:
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // optional string dbip = 13;
  bool has_dbip() const;
  private:
  bool _internal_has_dbip() const;
  public:
  void clear_dbip();
  const std::string& dbip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbip();
  PROTOBUF_NODISCARD std::string* release_dbip();
  void set_allocated_dbip(std::string* dbip);
  private:
  const std::string& _internal_dbip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbip(const std::string& value);
  std::string* _internal_mutable_dbip();
  public:

  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // int32 result = 2;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // optional int32 robotid = 3;
  bool has_robotid() const;
  private:
  bool _internal_has_robotid() const;
  public:
  void clear_robotid();
  int32_t robotid() const;
  void set_robotid(int32_t value);
  private:
  int32_t _internal_robotid() const;
  void _internal_set_robotid(int32_t value);
  public:

  // optional int32 users = 8;
  bool has_users() const;
  private:
  bool _internal_has_users() const;
  public:
  void clear_users();
  int32_t users() const;
  void set_users(int32_t value);
  private:
  int32_t _internal_users() const;
  void _internal_set_users(int32_t value);
  public:

  // optional int64 startuserid = 7;
  bool has_startuserid() const;
  private:
  bool _internal_has_startuserid() const;
  public:
  void clear_startuserid();
  int64_t startuserid() const;
  void set_startuserid(int64_t value);
  private:
  int64_t _internal_startuserid() const;
  void _internal_set_startuserid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Config_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr urladdr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr openprefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbuser_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbpwd_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbip_;
  int32_t version_;
  int32_t result_;
  int32_t robotid_;
  int32_t users_;
  int64_t startuserid_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Start_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Start_Ack) */ {
 public:
  inline Robot_Start_Ack() : Robot_Start_Ack(nullptr) {}
  ~Robot_Start_Ack() override;
  explicit constexpr Robot_Start_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Start_Ack(const Robot_Start_Ack& from);
  Robot_Start_Ack(Robot_Start_Ack&& from) noexcept
    : Robot_Start_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Start_Ack& operator=(const Robot_Start_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Start_Ack& operator=(Robot_Start_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Start_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Start_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Start_Ack*>(
               &_Robot_Start_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Robot_Start_Ack& a, Robot_Start_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Start_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Start_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Start_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Start_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Start_Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Start_Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Start_Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Start_Ack";
  }
  protected:
  explicit Robot_Start_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBehaviorFieldNumber = 3,
    kLoginintervalFieldNumber = 2,
    kStartusernumFieldNumber = 1,
  };
  // repeated string behavior = 3;
  int behavior_size() const;
  private:
  int _internal_behavior_size() const;
  public:
  void clear_behavior();
  const std::string& behavior(int index) const;
  std::string* mutable_behavior(int index);
  void set_behavior(int index, const std::string& value);
  void set_behavior(int index, std::string&& value);
  void set_behavior(int index, const char* value);
  void set_behavior(int index, const char* value, size_t size);
  std::string* add_behavior();
  void add_behavior(const std::string& value);
  void add_behavior(std::string&& value);
  void add_behavior(const char* value);
  void add_behavior(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& behavior() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_behavior();
  private:
  const std::string& _internal_behavior(int index) const;
  std::string* _internal_add_behavior();
  public:

  // int64 logininterval = 2;
  void clear_logininterval();
  int64_t logininterval() const;
  void set_logininterval(int64_t value);
  private:
  int64_t _internal_logininterval() const;
  void _internal_set_logininterval(int64_t value);
  public:

  // int32 startusernum = 1;
  void clear_startusernum();
  int32_t startusernum() const;
  void set_startusernum(int32_t value);
  private:
  int32_t _internal_startusernum() const;
  void _internal_set_startusernum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Start_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> behavior_;
  int64_t logininterval_;
  int32_t startusernum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Stop_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PRO.Robot_Stop_Ack) */ {
 public:
  inline Robot_Stop_Ack() : Robot_Stop_Ack(nullptr) {}
  explicit constexpr Robot_Stop_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Stop_Ack(const Robot_Stop_Ack& from);
  Robot_Stop_Ack(Robot_Stop_Ack&& from) noexcept
    : Robot_Stop_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Stop_Ack& operator=(const Robot_Stop_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Stop_Ack& operator=(Robot_Stop_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Stop_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Stop_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Stop_Ack*>(
               &_Robot_Stop_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Robot_Stop_Ack& a, Robot_Stop_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Stop_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Stop_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Stop_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Stop_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Robot_Stop_Ack& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Robot_Stop_Ack& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Stop_Ack";
  }
  protected:
  explicit Robot_Stop_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PRO.Robot_Stop_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Record_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Record_req) */ {
 public:
  inline Robot_Record_req() : Robot_Record_req(nullptr) {}
  ~Robot_Record_req() override;
  explicit constexpr Robot_Record_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Record_req(const Robot_Record_req& from);
  Robot_Record_req(Robot_Record_req&& from) noexcept
    : Robot_Record_req() {
    *this = ::std::move(from);
  }

  inline Robot_Record_req& operator=(const Robot_Record_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Record_req& operator=(Robot_Record_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Record_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Record_req* internal_default_instance() {
    return reinterpret_cast<const Robot_Record_req*>(
               &_Robot_Record_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Robot_Record_req& a, Robot_Record_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Record_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Record_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Record_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Record_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Record_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Record_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Record_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Record_req";
  }
  protected:
  explicit Robot_Record_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotidFieldNumber = 1,
    kLogsFieldNumber = 2,
  };
  // int32 robotid = 1;
  void clear_robotid();
  int32_t robotid() const;
  void set_robotid(int32_t value);
  private:
  int32_t _internal_robotid() const;
  void _internal_set_robotid(int32_t value);
  public:

  // int32 logs = 2;
  void clear_logs();
  int32_t logs() const;
  void set_logs(int32_t value);
  private:
  int32_t _internal_logs() const;
  void _internal_set_logs(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Record_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t robotid_;
  int32_t logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_StartRecord_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_StartRecord_req) */ {
 public:
  inline Robot_StartRecord_req() : Robot_StartRecord_req(nullptr) {}
  ~Robot_StartRecord_req() override;
  explicit constexpr Robot_StartRecord_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_StartRecord_req(const Robot_StartRecord_req& from);
  Robot_StartRecord_req(Robot_StartRecord_req&& from) noexcept
    : Robot_StartRecord_req() {
    *this = ::std::move(from);
  }

  inline Robot_StartRecord_req& operator=(const Robot_StartRecord_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_StartRecord_req& operator=(Robot_StartRecord_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_StartRecord_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_StartRecord_req* internal_default_instance() {
    return reinterpret_cast<const Robot_StartRecord_req*>(
               &_Robot_StartRecord_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Robot_StartRecord_req& a, Robot_StartRecord_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_StartRecord_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_StartRecord_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_StartRecord_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_StartRecord_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_StartRecord_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_StartRecord_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_StartRecord_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_StartRecord_req";
  }
  protected:
  explicit Robot_StartRecord_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotidFieldNumber = 1,
  };
  // int32 robotid = 1;
  void clear_robotid();
  int32_t robotid() const;
  void set_robotid(int32_t value);
  private:
  int32_t _internal_robotid() const;
  void _internal_set_robotid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_StartRecord_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t robotid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_EndRecord_req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_EndRecord_req) */ {
 public:
  inline Robot_EndRecord_req() : Robot_EndRecord_req(nullptr) {}
  ~Robot_EndRecord_req() override;
  explicit constexpr Robot_EndRecord_req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_EndRecord_req(const Robot_EndRecord_req& from);
  Robot_EndRecord_req(Robot_EndRecord_req&& from) noexcept
    : Robot_EndRecord_req() {
    *this = ::std::move(from);
  }

  inline Robot_EndRecord_req& operator=(const Robot_EndRecord_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_EndRecord_req& operator=(Robot_EndRecord_req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_EndRecord_req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_EndRecord_req* internal_default_instance() {
    return reinterpret_cast<const Robot_EndRecord_req*>(
               &_Robot_EndRecord_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Robot_EndRecord_req& a, Robot_EndRecord_req& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_EndRecord_req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_EndRecord_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_EndRecord_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_EndRecord_req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_EndRecord_req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_EndRecord_req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_EndRecord_req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_EndRecord_req";
  }
  protected:
  explicit Robot_EndRecord_req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotidFieldNumber = 1,
    kLogsFieldNumber = 2,
  };
  // int32 robotid = 1;
  void clear_robotid();
  int32_t robotid() const;
  void set_robotid(int32_t value);
  private:
  int32_t _internal_robotid() const;
  void _internal_set_robotid(int32_t value);
  public:

  // int32 logs = 2;
  void clear_logs();
  int32_t logs() const;
  void set_logs(int32_t value);
  private:
  int32_t _internal_logs() const;
  void _internal_set_logs(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_EndRecord_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t robotid_;
  int32_t logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_UploadLogs_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PRO.Robot_UploadLogs_ntf) */ {
 public:
  inline Robot_UploadLogs_ntf() : Robot_UploadLogs_ntf(nullptr) {}
  explicit constexpr Robot_UploadLogs_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_UploadLogs_ntf(const Robot_UploadLogs_ntf& from);
  Robot_UploadLogs_ntf(Robot_UploadLogs_ntf&& from) noexcept
    : Robot_UploadLogs_ntf() {
    *this = ::std::move(from);
  }

  inline Robot_UploadLogs_ntf& operator=(const Robot_UploadLogs_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_UploadLogs_ntf& operator=(Robot_UploadLogs_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_UploadLogs_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_UploadLogs_ntf* internal_default_instance() {
    return reinterpret_cast<const Robot_UploadLogs_ntf*>(
               &_Robot_UploadLogs_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Robot_UploadLogs_ntf& a, Robot_UploadLogs_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_UploadLogs_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_UploadLogs_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_UploadLogs_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_UploadLogs_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Robot_UploadLogs_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Robot_UploadLogs_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_UploadLogs_ntf";
  }
  protected:
  explicit Robot_UploadLogs_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PRO.Robot_UploadLogs_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_ClearLogs_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PRO.Robot_ClearLogs_ntf) */ {
 public:
  inline Robot_ClearLogs_ntf() : Robot_ClearLogs_ntf(nullptr) {}
  explicit constexpr Robot_ClearLogs_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_ClearLogs_ntf(const Robot_ClearLogs_ntf& from);
  Robot_ClearLogs_ntf(Robot_ClearLogs_ntf&& from) noexcept
    : Robot_ClearLogs_ntf() {
    *this = ::std::move(from);
  }

  inline Robot_ClearLogs_ntf& operator=(const Robot_ClearLogs_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_ClearLogs_ntf& operator=(Robot_ClearLogs_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_ClearLogs_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_ClearLogs_ntf* internal_default_instance() {
    return reinterpret_cast<const Robot_ClearLogs_ntf*>(
               &_Robot_ClearLogs_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Robot_ClearLogs_ntf& a, Robot_ClearLogs_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_ClearLogs_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_ClearLogs_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_ClearLogs_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_ClearLogs_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Robot_ClearLogs_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Robot_ClearLogs_ntf& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_ClearLogs_ntf";
  }
  protected:
  explicit Robot_ClearLogs_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PRO.Robot_ClearLogs_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_UserPrefixChg_ntf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_UserPrefixChg_ntf) */ {
 public:
  inline Robot_UserPrefixChg_ntf() : Robot_UserPrefixChg_ntf(nullptr) {}
  ~Robot_UserPrefixChg_ntf() override;
  explicit constexpr Robot_UserPrefixChg_ntf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_UserPrefixChg_ntf(const Robot_UserPrefixChg_ntf& from);
  Robot_UserPrefixChg_ntf(Robot_UserPrefixChg_ntf&& from) noexcept
    : Robot_UserPrefixChg_ntf() {
    *this = ::std::move(from);
  }

  inline Robot_UserPrefixChg_ntf& operator=(const Robot_UserPrefixChg_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_UserPrefixChg_ntf& operator=(Robot_UserPrefixChg_ntf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_UserPrefixChg_ntf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_UserPrefixChg_ntf* internal_default_instance() {
    return reinterpret_cast<const Robot_UserPrefixChg_ntf*>(
               &_Robot_UserPrefixChg_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Robot_UserPrefixChg_ntf& a, Robot_UserPrefixChg_ntf& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_UserPrefixChg_ntf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_UserPrefixChg_ntf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_UserPrefixChg_ntf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_UserPrefixChg_ntf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_UserPrefixChg_ntf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_UserPrefixChg_ntf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_UserPrefixChg_ntf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_UserPrefixChg_ntf";
  }
  protected:
  explicit Robot_UserPrefixChg_ntf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
  };
  // string prefix = 1;
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_UserPrefixChg_ntf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot_Config_Req

// int32 version = 1;
inline void Robot_Config_Req::clear_version() {
  version_ = 0;
}
inline int32_t Robot_Config_Req::_internal_version() const {
  return version_;
}
inline int32_t Robot_Config_Req::version() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.version)
  return _internal_version();
}
inline void Robot_Config_Req::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void Robot_Config_Req::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.version)
}

// string robotname = 2;
inline void Robot_Config_Req::clear_robotname() {
  robotname_.ClearToEmpty();
}
inline const std::string& Robot_Config_Req::robotname() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.robotname)
  return _internal_robotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Req::set_robotname(ArgT0&& arg0, ArgT... args) {
 
 robotname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.robotname)
}
inline std::string* Robot_Config_Req::mutable_robotname() {
  std::string* _s = _internal_mutable_robotname();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Req.robotname)
  return _s;
}
inline const std::string& Robot_Config_Req::_internal_robotname() const {
  return robotname_.Get();
}
inline void Robot_Config_Req::_internal_set_robotname(const std::string& value) {
  
  robotname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::_internal_mutable_robotname() {
  
  return robotname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::release_robotname() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Req.robotname)
  return robotname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot_Config_Req::set_allocated_robotname(std::string* robotname) {
  if (robotname != nullptr) {
    
  } else {
    
  }
  robotname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), robotname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    robotname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Req.robotname)
}

// string robotpwd = 3;
inline void Robot_Config_Req::clear_robotpwd() {
  robotpwd_.ClearToEmpty();
}
inline const std::string& Robot_Config_Req::robotpwd() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.robotpwd)
  return _internal_robotpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Req::set_robotpwd(ArgT0&& arg0, ArgT... args) {
 
 robotpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.robotpwd)
}
inline std::string* Robot_Config_Req::mutable_robotpwd() {
  std::string* _s = _internal_mutable_robotpwd();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Req.robotpwd)
  return _s;
}
inline const std::string& Robot_Config_Req::_internal_robotpwd() const {
  return robotpwd_.Get();
}
inline void Robot_Config_Req::_internal_set_robotpwd(const std::string& value) {
  
  robotpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::_internal_mutable_robotpwd() {
  
  return robotpwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::release_robotpwd() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Req.robotpwd)
  return robotpwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot_Config_Req::set_allocated_robotpwd(std::string* robotpwd) {
  if (robotpwd != nullptr) {
    
  } else {
    
  }
  robotpwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), robotpwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotpwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    robotpwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Req.robotpwd)
}

// -------------------------------------------------------------------

// Robot_Config_Ack

// int32 version = 1;
inline void Robot_Config_Ack::clear_version() {
  version_ = 0;
}
inline int32_t Robot_Config_Ack::_internal_version() const {
  return version_;
}
inline int32_t Robot_Config_Ack::version() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.version)
  return _internal_version();
}
inline void Robot_Config_Ack::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void Robot_Config_Ack::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.version)
}

// int32 result = 2;
inline void Robot_Config_Ack::clear_result() {
  result_ = 0;
}
inline int32_t Robot_Config_Ack::_internal_result() const {
  return result_;
}
inline int32_t Robot_Config_Ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.result)
  return _internal_result();
}
inline void Robot_Config_Ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Robot_Config_Ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.result)
}

// optional int32 robotid = 3;
inline bool Robot_Config_Ack::_internal_has_robotid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_robotid() const {
  return _internal_has_robotid();
}
inline void Robot_Config_Ack::clear_robotid() {
  robotid_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t Robot_Config_Ack::_internal_robotid() const {
  return robotid_;
}
inline int32_t Robot_Config_Ack::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.robotid)
  return _internal_robotid();
}
inline void Robot_Config_Ack::_internal_set_robotid(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  robotid_ = value;
}
inline void Robot_Config_Ack::set_robotid(int32_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.robotid)
}

// optional string urladdr = 4;
inline bool Robot_Config_Ack::_internal_has_urladdr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_urladdr() const {
  return _internal_has_urladdr();
}
inline void Robot_Config_Ack::clear_urladdr() {
  urladdr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Robot_Config_Ack::urladdr() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.urladdr)
  return _internal_urladdr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_urladdr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 urladdr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.urladdr)
}
inline std::string* Robot_Config_Ack::mutable_urladdr() {
  std::string* _s = _internal_mutable_urladdr();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.urladdr)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_urladdr() const {
  return urladdr_.Get();
}
inline void Robot_Config_Ack::_internal_set_urladdr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  urladdr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_urladdr() {
  _has_bits_[0] |= 0x00000001u;
  return urladdr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_urladdr() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.urladdr)
  if (!_internal_has_urladdr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = urladdr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (urladdr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    urladdr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_urladdr(std::string* urladdr) {
  if (urladdr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  urladdr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), urladdr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (urladdr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    urladdr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.urladdr)
}

// optional string openprefix = 5;
inline bool Robot_Config_Ack::_internal_has_openprefix() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_openprefix() const {
  return _internal_has_openprefix();
}
inline void Robot_Config_Ack::clear_openprefix() {
  openprefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Robot_Config_Ack::openprefix() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.openprefix)
  return _internal_openprefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_openprefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 openprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.openprefix)
}
inline std::string* Robot_Config_Ack::mutable_openprefix() {
  std::string* _s = _internal_mutable_openprefix();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.openprefix)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_openprefix() const {
  return openprefix_.Get();
}
inline void Robot_Config_Ack::_internal_set_openprefix(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  openprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_openprefix() {
  _has_bits_[0] |= 0x00000002u;
  return openprefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_openprefix() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.openprefix)
  if (!_internal_has_openprefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = openprefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (openprefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    openprefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_openprefix(std::string* openprefix) {
  if (openprefix != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  openprefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), openprefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (openprefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    openprefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.openprefix)
}

// optional int64 startuserid = 7;
inline bool Robot_Config_Ack::_internal_has_startuserid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_startuserid() const {
  return _internal_has_startuserid();
}
inline void Robot_Config_Ack::clear_startuserid() {
  startuserid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline int64_t Robot_Config_Ack::_internal_startuserid() const {
  return startuserid_;
}
inline int64_t Robot_Config_Ack::startuserid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.startuserid)
  return _internal_startuserid();
}
inline void Robot_Config_Ack::_internal_set_startuserid(int64_t value) {
  _has_bits_[0] |= 0x00000100u;
  startuserid_ = value;
}
inline void Robot_Config_Ack::set_startuserid(int64_t value) {
  _internal_set_startuserid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.startuserid)
}

// optional int32 users = 8;
inline bool Robot_Config_Ack::_internal_has_users() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_users() const {
  return _internal_has_users();
}
inline void Robot_Config_Ack::clear_users() {
  users_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t Robot_Config_Ack::_internal_users() const {
  return users_;
}
inline int32_t Robot_Config_Ack::users() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.users)
  return _internal_users();
}
inline void Robot_Config_Ack::_internal_set_users(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  users_ = value;
}
inline void Robot_Config_Ack::set_users(int32_t value) {
  _internal_set_users(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.users)
}

// optional string dbuser = 10;
inline bool Robot_Config_Ack::_internal_has_dbuser() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_dbuser() const {
  return _internal_has_dbuser();
}
inline void Robot_Config_Ack::clear_dbuser() {
  dbuser_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Robot_Config_Ack::dbuser() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.dbuser)
  return _internal_dbuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_dbuser(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 dbuser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.dbuser)
}
inline std::string* Robot_Config_Ack::mutable_dbuser() {
  std::string* _s = _internal_mutable_dbuser();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.dbuser)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_dbuser() const {
  return dbuser_.Get();
}
inline void Robot_Config_Ack::_internal_set_dbuser(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  dbuser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_dbuser() {
  _has_bits_[0] |= 0x00000004u;
  return dbuser_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_dbuser() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.dbuser)
  if (!_internal_has_dbuser()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = dbuser_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbuser_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbuser_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_dbuser(std::string* dbuser) {
  if (dbuser != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  dbuser_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dbuser,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbuser_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbuser_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.dbuser)
}

// optional string dbpwd = 11;
inline bool Robot_Config_Ack::_internal_has_dbpwd() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_dbpwd() const {
  return _internal_has_dbpwd();
}
inline void Robot_Config_Ack::clear_dbpwd() {
  dbpwd_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Robot_Config_Ack::dbpwd() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.dbpwd)
  return _internal_dbpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_dbpwd(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 dbpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.dbpwd)
}
inline std::string* Robot_Config_Ack::mutable_dbpwd() {
  std::string* _s = _internal_mutable_dbpwd();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.dbpwd)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_dbpwd() const {
  return dbpwd_.Get();
}
inline void Robot_Config_Ack::_internal_set_dbpwd(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  dbpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_dbpwd() {
  _has_bits_[0] |= 0x00000008u;
  return dbpwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_dbpwd() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.dbpwd)
  if (!_internal_has_dbpwd()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = dbpwd_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbpwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbpwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_dbpwd(std::string* dbpwd) {
  if (dbpwd != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dbpwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dbpwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbpwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbpwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.dbpwd)
}

// optional string dbname = 12;
inline bool Robot_Config_Ack::_internal_has_dbname() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_dbname() const {
  return _internal_has_dbname();
}
inline void Robot_Config_Ack::clear_dbname() {
  dbname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Robot_Config_Ack::dbname() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.dbname)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_dbname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 dbname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.dbname)
}
inline std::string* Robot_Config_Ack::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.dbname)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_dbname() const {
  return dbname_.Get();
}
inline void Robot_Config_Ack::_internal_set_dbname(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  dbname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_dbname() {
  _has_bits_[0] |= 0x00000010u;
  return dbname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_dbname() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.dbname)
  if (!_internal_has_dbname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = dbname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  dbname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dbname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.dbname)
}

// optional string dbip = 13;
inline bool Robot_Config_Ack::_internal_has_dbip() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_dbip() const {
  return _internal_has_dbip();
}
inline void Robot_Config_Ack::clear_dbip() {
  dbip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Robot_Config_Ack::dbip() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.dbip)
  return _internal_dbip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_dbip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 dbip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.dbip)
}
inline std::string* Robot_Config_Ack::mutable_dbip() {
  std::string* _s = _internal_mutable_dbip();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.dbip)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_dbip() const {
  return dbip_.Get();
}
inline void Robot_Config_Ack::_internal_set_dbip(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  dbip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_dbip() {
  _has_bits_[0] |= 0x00000020u;
  return dbip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_dbip() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.dbip)
  if (!_internal_has_dbip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = dbip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_dbip(std::string* dbip) {
  if (dbip != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  dbip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dbip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dbip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dbip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.dbip)
}

// -------------------------------------------------------------------

// Robot_Start_Ack

// int32 startusernum = 1;
inline void Robot_Start_Ack::clear_startusernum() {
  startusernum_ = 0;
}
inline int32_t Robot_Start_Ack::_internal_startusernum() const {
  return startusernum_;
}
inline int32_t Robot_Start_Ack::startusernum() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.startusernum)
  return _internal_startusernum();
}
inline void Robot_Start_Ack::_internal_set_startusernum(int32_t value) {
  
  startusernum_ = value;
}
inline void Robot_Start_Ack::set_startusernum(int32_t value) {
  _internal_set_startusernum(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.startusernum)
}

// int64 logininterval = 2;
inline void Robot_Start_Ack::clear_logininterval() {
  logininterval_ = int64_t{0};
}
inline int64_t Robot_Start_Ack::_internal_logininterval() const {
  return logininterval_;
}
inline int64_t Robot_Start_Ack::logininterval() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.logininterval)
  return _internal_logininterval();
}
inline void Robot_Start_Ack::_internal_set_logininterval(int64_t value) {
  
  logininterval_ = value;
}
inline void Robot_Start_Ack::set_logininterval(int64_t value) {
  _internal_set_logininterval(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.logininterval)
}

// repeated string behavior = 3;
inline int Robot_Start_Ack::_internal_behavior_size() const {
  return behavior_.size();
}
inline int Robot_Start_Ack::behavior_size() const {
  return _internal_behavior_size();
}
inline void Robot_Start_Ack::clear_behavior() {
  behavior_.Clear();
}
inline std::string* Robot_Start_Ack::add_behavior() {
  std::string* _s = _internal_add_behavior();
  // @@protoc_insertion_point(field_add_mutable:PRO.Robot_Start_Ack.behavior)
  return _s;
}
inline const std::string& Robot_Start_Ack::_internal_behavior(int index) const {
  return behavior_.Get(index);
}
inline const std::string& Robot_Start_Ack::behavior(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.behavior)
  return _internal_behavior(index);
}
inline std::string* Robot_Start_Ack::mutable_behavior(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Start_Ack.behavior)
  return behavior_.Mutable(index);
}
inline void Robot_Start_Ack::set_behavior(int index, const std::string& value) {
  behavior_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, std::string&& value) {
  behavior_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  behavior_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, const char* value, size_t size) {
  behavior_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PRO.Robot_Start_Ack.behavior)
}
inline std::string* Robot_Start_Ack::_internal_add_behavior() {
  return behavior_.Add();
}
inline void Robot_Start_Ack::add_behavior(const std::string& value) {
  behavior_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(std::string&& value) {
  behavior_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  behavior_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(const char* value, size_t size) {
  behavior_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PRO.Robot_Start_Ack.behavior)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Robot_Start_Ack::behavior() const {
  // @@protoc_insertion_point(field_list:PRO.Robot_Start_Ack.behavior)
  return behavior_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Robot_Start_Ack::mutable_behavior() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Robot_Start_Ack.behavior)
  return &behavior_;
}

// -------------------------------------------------------------------

// Robot_Stop_Ack

// -------------------------------------------------------------------

// Robot_Record_req

// int32 robotid = 1;
inline void Robot_Record_req::clear_robotid() {
  robotid_ = 0;
}
inline int32_t Robot_Record_req::_internal_robotid() const {
  return robotid_;
}
inline int32_t Robot_Record_req::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Record_req.robotid)
  return _internal_robotid();
}
inline void Robot_Record_req::_internal_set_robotid(int32_t value) {
  
  robotid_ = value;
}
inline void Robot_Record_req::set_robotid(int32_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Record_req.robotid)
}

// int32 logs = 2;
inline void Robot_Record_req::clear_logs() {
  logs_ = 0;
}
inline int32_t Robot_Record_req::_internal_logs() const {
  return logs_;
}
inline int32_t Robot_Record_req::logs() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Record_req.logs)
  return _internal_logs();
}
inline void Robot_Record_req::_internal_set_logs(int32_t value) {
  
  logs_ = value;
}
inline void Robot_Record_req::set_logs(int32_t value) {
  _internal_set_logs(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Record_req.logs)
}

// -------------------------------------------------------------------

// Robot_StartRecord_req

// int32 robotid = 1;
inline void Robot_StartRecord_req::clear_robotid() {
  robotid_ = 0;
}
inline int32_t Robot_StartRecord_req::_internal_robotid() const {
  return robotid_;
}
inline int32_t Robot_StartRecord_req::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_StartRecord_req.robotid)
  return _internal_robotid();
}
inline void Robot_StartRecord_req::_internal_set_robotid(int32_t value) {
  
  robotid_ = value;
}
inline void Robot_StartRecord_req::set_robotid(int32_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_StartRecord_req.robotid)
}

// -------------------------------------------------------------------

// Robot_EndRecord_req

// int32 robotid = 1;
inline void Robot_EndRecord_req::clear_robotid() {
  robotid_ = 0;
}
inline int32_t Robot_EndRecord_req::_internal_robotid() const {
  return robotid_;
}
inline int32_t Robot_EndRecord_req::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_EndRecord_req.robotid)
  return _internal_robotid();
}
inline void Robot_EndRecord_req::_internal_set_robotid(int32_t value) {
  
  robotid_ = value;
}
inline void Robot_EndRecord_req::set_robotid(int32_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_EndRecord_req.robotid)
}

// int32 logs = 2;
inline void Robot_EndRecord_req::clear_logs() {
  logs_ = 0;
}
inline int32_t Robot_EndRecord_req::_internal_logs() const {
  return logs_;
}
inline int32_t Robot_EndRecord_req::logs() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_EndRecord_req.logs)
  return _internal_logs();
}
inline void Robot_EndRecord_req::_internal_set_logs(int32_t value) {
  
  logs_ = value;
}
inline void Robot_EndRecord_req::set_logs(int32_t value) {
  _internal_set_logs(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_EndRecord_req.logs)
}

// -------------------------------------------------------------------

// Robot_UploadLogs_ntf

// -------------------------------------------------------------------

// Robot_ClearLogs_ntf

// -------------------------------------------------------------------

// Robot_UserPrefixChg_ntf

// string prefix = 1;
inline void Robot_UserPrefixChg_ntf::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& Robot_UserPrefixChg_ntf::prefix() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_UserPrefixChg_ntf.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_UserPrefixChg_ntf::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_UserPrefixChg_ntf.prefix)
}
inline std::string* Robot_UserPrefixChg_ntf::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_UserPrefixChg_ntf.prefix)
  return _s;
}
inline const std::string& Robot_UserPrefixChg_ntf::_internal_prefix() const {
  return prefix_.Get();
}
inline void Robot_UserPrefixChg_ntf::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_UserPrefixChg_ntf::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_UserPrefixChg_ntf::release_prefix() {
  // @@protoc_insertion_point(field_release:PRO.Robot_UserPrefixChg_ntf.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot_UserPrefixChg_ntf::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_UserPrefixChg_ntf.prefix)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PRO

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PRO::ROBOT_CONST> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRO::ROBOT_CONST>() {
  return ::PRO::ROBOT_CONST_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto
