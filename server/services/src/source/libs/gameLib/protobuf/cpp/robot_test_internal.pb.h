// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_test_internal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_5ftest_5finternal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5ftest_5finternal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5ftest_5finternal_2eproto;
namespace PRO {
class Robot_Config_Ack;
struct Robot_Config_AckDefaultTypeInternal;
extern Robot_Config_AckDefaultTypeInternal _Robot_Config_Ack_default_instance_;
class Robot_Config_Req;
struct Robot_Config_ReqDefaultTypeInternal;
extern Robot_Config_ReqDefaultTypeInternal _Robot_Config_Req_default_instance_;
class Robot_Start_Ack;
struct Robot_Start_AckDefaultTypeInternal;
extern Robot_Start_AckDefaultTypeInternal _Robot_Start_Ack_default_instance_;
class Robot_State_Ack;
struct Robot_State_AckDefaultTypeInternal;
extern Robot_State_AckDefaultTypeInternal _Robot_State_Ack_default_instance_;
class Robot_State_Rpt;
struct Robot_State_RptDefaultTypeInternal;
extern Robot_State_RptDefaultTypeInternal _Robot_State_Rpt_default_instance_;
class Robot_State_Rpt_ActionGroup;
struct Robot_State_Rpt_ActionGroupDefaultTypeInternal;
extern Robot_State_Rpt_ActionGroupDefaultTypeInternal _Robot_State_Rpt_ActionGroup_default_instance_;
class Robot_State_Rpt_StateData;
struct Robot_State_Rpt_StateDataDefaultTypeInternal;
extern Robot_State_Rpt_StateDataDefaultTypeInternal _Robot_State_Rpt_StateData_default_instance_;
class Robot_Stop_Ack;
struct Robot_Stop_AckDefaultTypeInternal;
extern Robot_Stop_AckDefaultTypeInternal _Robot_Stop_Ack_default_instance_;
}  // namespace PRO
PROTOBUF_NAMESPACE_OPEN
template<> ::PRO::Robot_Config_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Config_Ack>(Arena*);
template<> ::PRO::Robot_Config_Req* Arena::CreateMaybeMessage<::PRO::Robot_Config_Req>(Arena*);
template<> ::PRO::Robot_Start_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Start_Ack>(Arena*);
template<> ::PRO::Robot_State_Ack* Arena::CreateMaybeMessage<::PRO::Robot_State_Ack>(Arena*);
template<> ::PRO::Robot_State_Rpt* Arena::CreateMaybeMessage<::PRO::Robot_State_Rpt>(Arena*);
template<> ::PRO::Robot_State_Rpt_ActionGroup* Arena::CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(Arena*);
template<> ::PRO::Robot_State_Rpt_StateData* Arena::CreateMaybeMessage<::PRO::Robot_State_Rpt_StateData>(Arena*);
template<> ::PRO::Robot_Stop_Ack* Arena::CreateMaybeMessage<::PRO::Robot_Stop_Ack>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PRO {

enum ROBOT_CONST : int {
  ROBOT_CONST_UNIVERSAL = 0,
  ROBOT_VERSION = 1,
  ROBOT_CONST_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ROBOT_CONST_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ROBOT_CONST_IsValid(int value);
constexpr ROBOT_CONST ROBOT_CONST_MIN = ROBOT_CONST_UNIVERSAL;
constexpr ROBOT_CONST ROBOT_CONST_MAX = ROBOT_VERSION;
constexpr int ROBOT_CONST_ARRAYSIZE = ROBOT_CONST_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ROBOT_CONST_descriptor();
template<typename T>
inline const std::string& ROBOT_CONST_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ROBOT_CONST>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ROBOT_CONST_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ROBOT_CONST_descriptor(), enum_t_value);
}
inline bool ROBOT_CONST_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ROBOT_CONST* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ROBOT_CONST>(
    ROBOT_CONST_descriptor(), name, value);
}
// ===================================================================

class Robot_Config_Req final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Config_Req) */ {
 public:
  inline Robot_Config_Req() : Robot_Config_Req(nullptr) {}
  ~Robot_Config_Req() override;
  explicit constexpr Robot_Config_Req(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Config_Req(const Robot_Config_Req& from);
  Robot_Config_Req(Robot_Config_Req&& from) noexcept
    : Robot_Config_Req() {
    *this = ::std::move(from);
  }

  inline Robot_Config_Req& operator=(const Robot_Config_Req& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Config_Req& operator=(Robot_Config_Req&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Config_Req& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Config_Req* internal_default_instance() {
    return reinterpret_cast<const Robot_Config_Req*>(
               &_Robot_Config_Req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robot_Config_Req& a, Robot_Config_Req& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Config_Req* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Config_Req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Config_Req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Config_Req>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Config_Req& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Config_Req& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Config_Req* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Config_Req";
  }
  protected:
  explicit Robot_Config_Req(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotnameFieldNumber = 2,
    kRobotpwdFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // string robotname = 2;
  void clear_robotname();
  const std::string& robotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotname();
  PROTOBUF_NODISCARD std::string* release_robotname();
  void set_allocated_robotname(std::string* robotname);
  private:
  const std::string& _internal_robotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotname(const std::string& value);
  std::string* _internal_mutable_robotname();
  public:

  // string robotpwd = 3;
  void clear_robotpwd();
  const std::string& robotpwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotpwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotpwd();
  PROTOBUF_NODISCARD std::string* release_robotpwd();
  void set_allocated_robotpwd(std::string* robotpwd);
  private:
  const std::string& _internal_robotpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotpwd(const std::string& value);
  std::string* _internal_mutable_robotpwd();
  public:

  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Config_Req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotpwd_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Config_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Config_Ack) */ {
 public:
  inline Robot_Config_Ack() : Robot_Config_Ack(nullptr) {}
  ~Robot_Config_Ack() override;
  explicit constexpr Robot_Config_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Config_Ack(const Robot_Config_Ack& from);
  Robot_Config_Ack(Robot_Config_Ack&& from) noexcept
    : Robot_Config_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Config_Ack& operator=(const Robot_Config_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Config_Ack& operator=(Robot_Config_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Config_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Config_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Config_Ack*>(
               &_Robot_Config_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Robot_Config_Ack& a, Robot_Config_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Config_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Config_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Config_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Config_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Config_Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Config_Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Config_Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Config_Ack";
  }
  protected:
  explicit Robot_Config_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLgsipFieldNumber = 7,
    kVersionFieldNumber = 1,
    kResultFieldNumber = 2,
    kStartuseridFieldNumber = 4,
    kRobotidFieldNumber = 3,
    kUsersFieldNumber = 5,
    kUsersrangeFieldNumber = 6,
    kLgsportFieldNumber = 8,
  };
  // optional string lgsip = 7;
  bool has_lgsip() const;
  private:
  bool _internal_has_lgsip() const;
  public:
  void clear_lgsip();
  const std::string& lgsip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lgsip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lgsip();
  PROTOBUF_NODISCARD std::string* release_lgsip();
  void set_allocated_lgsip(std::string* lgsip);
  private:
  const std::string& _internal_lgsip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lgsip(const std::string& value);
  std::string* _internal_mutable_lgsip();
  public:

  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // int32 result = 2;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // optional int64 startuserid = 4;
  bool has_startuserid() const;
  private:
  bool _internal_has_startuserid() const;
  public:
  void clear_startuserid();
  int64_t startuserid() const;
  void set_startuserid(int64_t value);
  private:
  int64_t _internal_startuserid() const;
  void _internal_set_startuserid(int64_t value);
  public:

  // optional int32 robotid = 3;
  bool has_robotid() const;
  private:
  bool _internal_has_robotid() const;
  public:
  void clear_robotid();
  int32_t robotid() const;
  void set_robotid(int32_t value);
  private:
  int32_t _internal_robotid() const;
  void _internal_set_robotid(int32_t value);
  public:

  // optional int32 users = 5;
  bool has_users() const;
  private:
  bool _internal_has_users() const;
  public:
  void clear_users();
  int32_t users() const;
  void set_users(int32_t value);
  private:
  int32_t _internal_users() const;
  void _internal_set_users(int32_t value);
  public:

  // optional int32 usersrange = 6;
  bool has_usersrange() const;
  private:
  bool _internal_has_usersrange() const;
  public:
  void clear_usersrange();
  int32_t usersrange() const;
  void set_usersrange(int32_t value);
  private:
  int32_t _internal_usersrange() const;
  void _internal_set_usersrange(int32_t value);
  public:

  // optional int32 lgsport = 8;
  bool has_lgsport() const;
  private:
  bool _internal_has_lgsport() const;
  public:
  void clear_lgsport();
  int32_t lgsport() const;
  void set_lgsport(int32_t value);
  private:
  int32_t _internal_lgsport() const;
  void _internal_set_lgsport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Config_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lgsip_;
  int32_t version_;
  int32_t result_;
  int64_t startuserid_;
  int32_t robotid_;
  int32_t users_;
  int32_t usersrange_;
  int32_t lgsport_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Start_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_Start_Ack) */ {
 public:
  inline Robot_Start_Ack() : Robot_Start_Ack(nullptr) {}
  ~Robot_Start_Ack() override;
  explicit constexpr Robot_Start_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Start_Ack(const Robot_Start_Ack& from);
  Robot_Start_Ack(Robot_Start_Ack&& from) noexcept
    : Robot_Start_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Start_Ack& operator=(const Robot_Start_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Start_Ack& operator=(Robot_Start_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Start_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Start_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Start_Ack*>(
               &_Robot_Start_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Robot_Start_Ack& a, Robot_Start_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Start_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Start_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Start_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Start_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_Start_Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_Start_Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Start_Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Start_Ack";
  }
  protected:
  explicit Robot_Start_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBehaviorFieldNumber = 3,
    kLoginintervalFieldNumber = 2,
    kStartusernumFieldNumber = 1,
  };
  // repeated string behavior = 3;
  int behavior_size() const;
  private:
  int _internal_behavior_size() const;
  public:
  void clear_behavior();
  const std::string& behavior(int index) const;
  std::string* mutable_behavior(int index);
  void set_behavior(int index, const std::string& value);
  void set_behavior(int index, std::string&& value);
  void set_behavior(int index, const char* value);
  void set_behavior(int index, const char* value, size_t size);
  std::string* add_behavior();
  void add_behavior(const std::string& value);
  void add_behavior(std::string&& value);
  void add_behavior(const char* value);
  void add_behavior(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& behavior() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_behavior();
  private:
  const std::string& _internal_behavior(int index) const;
  std::string* _internal_add_behavior();
  public:

  // int64 logininterval = 2;
  void clear_logininterval();
  int64_t logininterval() const;
  void set_logininterval(int64_t value);
  private:
  int64_t _internal_logininterval() const;
  void _internal_set_logininterval(int64_t value);
  public:

  // int32 startusernum = 1;
  void clear_startusernum();
  int32_t startusernum() const;
  void set_startusernum(int32_t value);
  private:
  int32_t _internal_startusernum() const;
  void _internal_set_startusernum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_Start_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> behavior_;
  int64_t logininterval_;
  int32_t startusernum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_Stop_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:PRO.Robot_Stop_Ack) */ {
 public:
  inline Robot_Stop_Ack() : Robot_Stop_Ack(nullptr) {}
  explicit constexpr Robot_Stop_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_Stop_Ack(const Robot_Stop_Ack& from);
  Robot_Stop_Ack(Robot_Stop_Ack&& from) noexcept
    : Robot_Stop_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_Stop_Ack& operator=(const Robot_Stop_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Stop_Ack& operator=(Robot_Stop_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_Stop_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_Stop_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_Stop_Ack*>(
               &_Robot_Stop_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Robot_Stop_Ack& a, Robot_Stop_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Stop_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Stop_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_Stop_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_Stop_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Robot_Stop_Ack& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Robot_Stop_Ack& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_Stop_Ack";
  }
  protected:
  explicit Robot_Stop_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PRO.Robot_Stop_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_State_Rpt_ActionGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_State_Rpt.ActionGroup) */ {
 public:
  inline Robot_State_Rpt_ActionGroup() : Robot_State_Rpt_ActionGroup(nullptr) {}
  ~Robot_State_Rpt_ActionGroup() override;
  explicit constexpr Robot_State_Rpt_ActionGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_State_Rpt_ActionGroup(const Robot_State_Rpt_ActionGroup& from);
  Robot_State_Rpt_ActionGroup(Robot_State_Rpt_ActionGroup&& from) noexcept
    : Robot_State_Rpt_ActionGroup() {
    *this = ::std::move(from);
  }

  inline Robot_State_Rpt_ActionGroup& operator=(const Robot_State_Rpt_ActionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_State_Rpt_ActionGroup& operator=(Robot_State_Rpt_ActionGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_State_Rpt_ActionGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_State_Rpt_ActionGroup* internal_default_instance() {
    return reinterpret_cast<const Robot_State_Rpt_ActionGroup*>(
               &_Robot_State_Rpt_ActionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Robot_State_Rpt_ActionGroup& a, Robot_State_Rpt_ActionGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_State_Rpt_ActionGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_State_Rpt_ActionGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_State_Rpt_ActionGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_State_Rpt_ActionGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_State_Rpt_ActionGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_State_Rpt_ActionGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_State_Rpt_ActionGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_State_Rpt.ActionGroup";
  }
  protected:
  explicit Robot_State_Rpt_ActionGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kSucceedsFieldNumber = 2,
    kFailedsFieldNumber = 3,
    kTimeoutsFieldNumber = 4,
    kTimeintervalFieldNumber = 5,
  };
  // int64 actions = 1;
  void clear_actions();
  int64_t actions() const;
  void set_actions(int64_t value);
  private:
  int64_t _internal_actions() const;
  void _internal_set_actions(int64_t value);
  public:

  // int64 succeeds = 2;
  void clear_succeeds();
  int64_t succeeds() const;
  void set_succeeds(int64_t value);
  private:
  int64_t _internal_succeeds() const;
  void _internal_set_succeeds(int64_t value);
  public:

  // int64 faileds = 3;
  void clear_faileds();
  int64_t faileds() const;
  void set_faileds(int64_t value);
  private:
  int64_t _internal_faileds() const;
  void _internal_set_faileds(int64_t value);
  public:

  // int64 timeouts = 4;
  void clear_timeouts();
  int64_t timeouts() const;
  void set_timeouts(int64_t value);
  private:
  int64_t _internal_timeouts() const;
  void _internal_set_timeouts(int64_t value);
  public:

  // int64 timeinterval = 5;
  void clear_timeinterval();
  int64_t timeinterval() const;
  void set_timeinterval(int64_t value);
  private:
  int64_t _internal_timeinterval() const;
  void _internal_set_timeinterval(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_State_Rpt.ActionGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t actions_;
  int64_t succeeds_;
  int64_t faileds_;
  int64_t timeouts_;
  int64_t timeinterval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_State_Rpt_StateData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_State_Rpt.StateData) */ {
 public:
  inline Robot_State_Rpt_StateData() : Robot_State_Rpt_StateData(nullptr) {}
  ~Robot_State_Rpt_StateData() override;
  explicit constexpr Robot_State_Rpt_StateData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_State_Rpt_StateData(const Robot_State_Rpt_StateData& from);
  Robot_State_Rpt_StateData(Robot_State_Rpt_StateData&& from) noexcept
    : Robot_State_Rpt_StateData() {
    *this = ::std::move(from);
  }

  inline Robot_State_Rpt_StateData& operator=(const Robot_State_Rpt_StateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_State_Rpt_StateData& operator=(Robot_State_Rpt_StateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_State_Rpt_StateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_State_Rpt_StateData* internal_default_instance() {
    return reinterpret_cast<const Robot_State_Rpt_StateData*>(
               &_Robot_State_Rpt_StateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Robot_State_Rpt_StateData& a, Robot_State_Rpt_StateData& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_State_Rpt_StateData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_State_Rpt_StateData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_State_Rpt_StateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_State_Rpt_StateData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_State_Rpt_StateData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_State_Rpt_StateData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_State_Rpt_StateData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_State_Rpt.StateData";
  }
  protected:
  explicit Robot_State_Rpt_StateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogonFieldNumber = 1,
    kGetroleFieldNumber = 2,
    kSelroleFieldNumber = 3,
    kGetchannelFieldNumber = 4,
    kSelchannelFieldNumber = 5,
    kGetroomFieldNumber = 6,
    kLoginroomFieldNumber = 7,
    kLogoutroomFieldNumber = 8,
    kLogoutchannelFieldNumber = 9,
    kLogoutFieldNumber = 10,
  };
  // .PRO.Robot_State_Rpt.ActionGroup logon = 1;
  bool has_logon() const;
  private:
  bool _internal_has_logon() const;
  public:
  void clear_logon();
  const ::PRO::Robot_State_Rpt_ActionGroup& logon() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_logon();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_logon();
  void set_allocated_logon(::PRO::Robot_State_Rpt_ActionGroup* logon);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_logon() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_logon();
  public:
  void unsafe_arena_set_allocated_logon(
      ::PRO::Robot_State_Rpt_ActionGroup* logon);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_logon();

  // .PRO.Robot_State_Rpt.ActionGroup getrole = 2;
  bool has_getrole() const;
  private:
  bool _internal_has_getrole() const;
  public:
  void clear_getrole();
  const ::PRO::Robot_State_Rpt_ActionGroup& getrole() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_getrole();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_getrole();
  void set_allocated_getrole(::PRO::Robot_State_Rpt_ActionGroup* getrole);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_getrole() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_getrole();
  public:
  void unsafe_arena_set_allocated_getrole(
      ::PRO::Robot_State_Rpt_ActionGroup* getrole);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_getrole();

  // .PRO.Robot_State_Rpt.ActionGroup selrole = 3;
  bool has_selrole() const;
  private:
  bool _internal_has_selrole() const;
  public:
  void clear_selrole();
  const ::PRO::Robot_State_Rpt_ActionGroup& selrole() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_selrole();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_selrole();
  void set_allocated_selrole(::PRO::Robot_State_Rpt_ActionGroup* selrole);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_selrole() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_selrole();
  public:
  void unsafe_arena_set_allocated_selrole(
      ::PRO::Robot_State_Rpt_ActionGroup* selrole);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_selrole();

  // .PRO.Robot_State_Rpt.ActionGroup getchannel = 4;
  bool has_getchannel() const;
  private:
  bool _internal_has_getchannel() const;
  public:
  void clear_getchannel();
  const ::PRO::Robot_State_Rpt_ActionGroup& getchannel() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_getchannel();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_getchannel();
  void set_allocated_getchannel(::PRO::Robot_State_Rpt_ActionGroup* getchannel);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_getchannel() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_getchannel();
  public:
  void unsafe_arena_set_allocated_getchannel(
      ::PRO::Robot_State_Rpt_ActionGroup* getchannel);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_getchannel();

  // .PRO.Robot_State_Rpt.ActionGroup selchannel = 5;
  bool has_selchannel() const;
  private:
  bool _internal_has_selchannel() const;
  public:
  void clear_selchannel();
  const ::PRO::Robot_State_Rpt_ActionGroup& selchannel() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_selchannel();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_selchannel();
  void set_allocated_selchannel(::PRO::Robot_State_Rpt_ActionGroup* selchannel);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_selchannel() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_selchannel();
  public:
  void unsafe_arena_set_allocated_selchannel(
      ::PRO::Robot_State_Rpt_ActionGroup* selchannel);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_selchannel();

  // .PRO.Robot_State_Rpt.ActionGroup getroom = 6;
  bool has_getroom() const;
  private:
  bool _internal_has_getroom() const;
  public:
  void clear_getroom();
  const ::PRO::Robot_State_Rpt_ActionGroup& getroom() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_getroom();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_getroom();
  void set_allocated_getroom(::PRO::Robot_State_Rpt_ActionGroup* getroom);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_getroom() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_getroom();
  public:
  void unsafe_arena_set_allocated_getroom(
      ::PRO::Robot_State_Rpt_ActionGroup* getroom);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_getroom();

  // .PRO.Robot_State_Rpt.ActionGroup loginroom = 7;
  bool has_loginroom() const;
  private:
  bool _internal_has_loginroom() const;
  public:
  void clear_loginroom();
  const ::PRO::Robot_State_Rpt_ActionGroup& loginroom() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_loginroom();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_loginroom();
  void set_allocated_loginroom(::PRO::Robot_State_Rpt_ActionGroup* loginroom);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_loginroom() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_loginroom();
  public:
  void unsafe_arena_set_allocated_loginroom(
      ::PRO::Robot_State_Rpt_ActionGroup* loginroom);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_loginroom();

  // .PRO.Robot_State_Rpt.ActionGroup logoutroom = 8;
  bool has_logoutroom() const;
  private:
  bool _internal_has_logoutroom() const;
  public:
  void clear_logoutroom();
  const ::PRO::Robot_State_Rpt_ActionGroup& logoutroom() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_logoutroom();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_logoutroom();
  void set_allocated_logoutroom(::PRO::Robot_State_Rpt_ActionGroup* logoutroom);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_logoutroom() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_logoutroom();
  public:
  void unsafe_arena_set_allocated_logoutroom(
      ::PRO::Robot_State_Rpt_ActionGroup* logoutroom);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_logoutroom();

  // .PRO.Robot_State_Rpt.ActionGroup logoutchannel = 9;
  bool has_logoutchannel() const;
  private:
  bool _internal_has_logoutchannel() const;
  public:
  void clear_logoutchannel();
  const ::PRO::Robot_State_Rpt_ActionGroup& logoutchannel() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_logoutchannel();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_logoutchannel();
  void set_allocated_logoutchannel(::PRO::Robot_State_Rpt_ActionGroup* logoutchannel);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_logoutchannel() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_logoutchannel();
  public:
  void unsafe_arena_set_allocated_logoutchannel(
      ::PRO::Robot_State_Rpt_ActionGroup* logoutchannel);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_logoutchannel();

  // .PRO.Robot_State_Rpt.ActionGroup logout = 10;
  bool has_logout() const;
  private:
  bool _internal_has_logout() const;
  public:
  void clear_logout();
  const ::PRO::Robot_State_Rpt_ActionGroup& logout() const;
  PROTOBUF_NODISCARD ::PRO::Robot_State_Rpt_ActionGroup* release_logout();
  ::PRO::Robot_State_Rpt_ActionGroup* mutable_logout();
  void set_allocated_logout(::PRO::Robot_State_Rpt_ActionGroup* logout);
  private:
  const ::PRO::Robot_State_Rpt_ActionGroup& _internal_logout() const;
  ::PRO::Robot_State_Rpt_ActionGroup* _internal_mutable_logout();
  public:
  void unsafe_arena_set_allocated_logout(
      ::PRO::Robot_State_Rpt_ActionGroup* logout);
  ::PRO::Robot_State_Rpt_ActionGroup* unsafe_arena_release_logout();

  // @@protoc_insertion_point(class_scope:PRO.Robot_State_Rpt.StateData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PRO::Robot_State_Rpt_ActionGroup* logon_;
  ::PRO::Robot_State_Rpt_ActionGroup* getrole_;
  ::PRO::Robot_State_Rpt_ActionGroup* selrole_;
  ::PRO::Robot_State_Rpt_ActionGroup* getchannel_;
  ::PRO::Robot_State_Rpt_ActionGroup* selchannel_;
  ::PRO::Robot_State_Rpt_ActionGroup* getroom_;
  ::PRO::Robot_State_Rpt_ActionGroup* loginroom_;
  ::PRO::Robot_State_Rpt_ActionGroup* logoutroom_;
  ::PRO::Robot_State_Rpt_ActionGroup* logoutchannel_;
  ::PRO::Robot_State_Rpt_ActionGroup* logout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_State_Rpt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_State_Rpt) */ {
 public:
  inline Robot_State_Rpt() : Robot_State_Rpt(nullptr) {}
  ~Robot_State_Rpt() override;
  explicit constexpr Robot_State_Rpt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_State_Rpt(const Robot_State_Rpt& from);
  Robot_State_Rpt(Robot_State_Rpt&& from) noexcept
    : Robot_State_Rpt() {
    *this = ::std::move(from);
  }

  inline Robot_State_Rpt& operator=(const Robot_State_Rpt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_State_Rpt& operator=(Robot_State_Rpt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_State_Rpt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_State_Rpt* internal_default_instance() {
    return reinterpret_cast<const Robot_State_Rpt*>(
               &_Robot_State_Rpt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Robot_State_Rpt& a, Robot_State_Rpt& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_State_Rpt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_State_Rpt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_State_Rpt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_State_Rpt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_State_Rpt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_State_Rpt& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_State_Rpt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_State_Rpt";
  }
  protected:
  explicit Robot_State_Rpt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Robot_State_Rpt_ActionGroup ActionGroup;
  typedef Robot_State_Rpt_StateData StateData;

  // accessors -------------------------------------------------------

  enum : int {
    kStatDataFieldNumber = 2,
    kRobotidFieldNumber = 1,
  };
  // repeated .PRO.Robot_State_Rpt.StateData stat_data = 2;
  int stat_data_size() const;
  private:
  int _internal_stat_data_size() const;
  public:
  void clear_stat_data();
  ::PRO::Robot_State_Rpt_StateData* mutable_stat_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Robot_State_Rpt_StateData >*
      mutable_stat_data();
  private:
  const ::PRO::Robot_State_Rpt_StateData& _internal_stat_data(int index) const;
  ::PRO::Robot_State_Rpt_StateData* _internal_add_stat_data();
  public:
  const ::PRO::Robot_State_Rpt_StateData& stat_data(int index) const;
  ::PRO::Robot_State_Rpt_StateData* add_stat_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Robot_State_Rpt_StateData >&
      stat_data() const;

  // int64 robotid = 1;
  void clear_robotid();
  int64_t robotid() const;
  void set_robotid(int64_t value);
  private:
  int64_t _internal_robotid() const;
  void _internal_set_robotid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_State_Rpt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Robot_State_Rpt_StateData > stat_data_;
  int64_t robotid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// -------------------------------------------------------------------

class Robot_State_Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PRO.Robot_State_Ack) */ {
 public:
  inline Robot_State_Ack() : Robot_State_Ack(nullptr) {}
  ~Robot_State_Ack() override;
  explicit constexpr Robot_State_Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Robot_State_Ack(const Robot_State_Ack& from);
  Robot_State_Ack(Robot_State_Ack&& from) noexcept
    : Robot_State_Ack() {
    *this = ::std::move(from);
  }

  inline Robot_State_Ack& operator=(const Robot_State_Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_State_Ack& operator=(Robot_State_Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Robot_State_Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Robot_State_Ack* internal_default_instance() {
    return reinterpret_cast<const Robot_State_Ack*>(
               &_Robot_State_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Robot_State_Ack& a, Robot_State_Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_State_Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_State_Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Robot_State_Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Robot_State_Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Robot_State_Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Robot_State_Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_State_Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PRO.Robot_State_Ack";
  }
  protected:
  explicit Robot_State_Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // int64 userid = 1;
  void clear_userid();
  int64_t userid() const;
  void set_userid(int64_t value);
  private:
  int64_t _internal_userid() const;
  void _internal_set_userid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PRO.Robot_State_Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5ftest_5finternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robot_Config_Req

// int32 version = 1;
inline void Robot_Config_Req::clear_version() {
  version_ = 0;
}
inline int32_t Robot_Config_Req::_internal_version() const {
  return version_;
}
inline int32_t Robot_Config_Req::version() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.version)
  return _internal_version();
}
inline void Robot_Config_Req::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void Robot_Config_Req::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.version)
}

// string robotname = 2;
inline void Robot_Config_Req::clear_robotname() {
  robotname_.ClearToEmpty();
}
inline const std::string& Robot_Config_Req::robotname() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.robotname)
  return _internal_robotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Req::set_robotname(ArgT0&& arg0, ArgT... args) {
 
 robotname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.robotname)
}
inline std::string* Robot_Config_Req::mutable_robotname() {
  std::string* _s = _internal_mutable_robotname();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Req.robotname)
  return _s;
}
inline const std::string& Robot_Config_Req::_internal_robotname() const {
  return robotname_.Get();
}
inline void Robot_Config_Req::_internal_set_robotname(const std::string& value) {
  
  robotname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::_internal_mutable_robotname() {
  
  return robotname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::release_robotname() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Req.robotname)
  return robotname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot_Config_Req::set_allocated_robotname(std::string* robotname) {
  if (robotname != nullptr) {
    
  } else {
    
  }
  robotname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), robotname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    robotname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Req.robotname)
}

// string robotpwd = 3;
inline void Robot_Config_Req::clear_robotpwd() {
  robotpwd_.ClearToEmpty();
}
inline const std::string& Robot_Config_Req::robotpwd() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Req.robotpwd)
  return _internal_robotpwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Req::set_robotpwd(ArgT0&& arg0, ArgT... args) {
 
 robotpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Req.robotpwd)
}
inline std::string* Robot_Config_Req::mutable_robotpwd() {
  std::string* _s = _internal_mutable_robotpwd();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Req.robotpwd)
  return _s;
}
inline const std::string& Robot_Config_Req::_internal_robotpwd() const {
  return robotpwd_.Get();
}
inline void Robot_Config_Req::_internal_set_robotpwd(const std::string& value) {
  
  robotpwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::_internal_mutable_robotpwd() {
  
  return robotpwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Req::release_robotpwd() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Req.robotpwd)
  return robotpwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Robot_Config_Req::set_allocated_robotpwd(std::string* robotpwd) {
  if (robotpwd != nullptr) {
    
  } else {
    
  }
  robotpwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), robotpwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotpwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    robotpwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Req.robotpwd)
}

// -------------------------------------------------------------------

// Robot_Config_Ack

// int32 version = 1;
inline void Robot_Config_Ack::clear_version() {
  version_ = 0;
}
inline int32_t Robot_Config_Ack::_internal_version() const {
  return version_;
}
inline int32_t Robot_Config_Ack::version() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.version)
  return _internal_version();
}
inline void Robot_Config_Ack::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void Robot_Config_Ack::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.version)
}

// int32 result = 2;
inline void Robot_Config_Ack::clear_result() {
  result_ = 0;
}
inline int32_t Robot_Config_Ack::_internal_result() const {
  return result_;
}
inline int32_t Robot_Config_Ack::result() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.result)
  return _internal_result();
}
inline void Robot_Config_Ack::_internal_set_result(int32_t value) {
  
  result_ = value;
}
inline void Robot_Config_Ack::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.result)
}

// optional int32 robotid = 3;
inline bool Robot_Config_Ack::_internal_has_robotid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_robotid() const {
  return _internal_has_robotid();
}
inline void Robot_Config_Ack::clear_robotid() {
  robotid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Robot_Config_Ack::_internal_robotid() const {
  return robotid_;
}
inline int32_t Robot_Config_Ack::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.robotid)
  return _internal_robotid();
}
inline void Robot_Config_Ack::_internal_set_robotid(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  robotid_ = value;
}
inline void Robot_Config_Ack::set_robotid(int32_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.robotid)
}

// optional int64 startuserid = 4;
inline bool Robot_Config_Ack::_internal_has_startuserid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_startuserid() const {
  return _internal_has_startuserid();
}
inline void Robot_Config_Ack::clear_startuserid() {
  startuserid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t Robot_Config_Ack::_internal_startuserid() const {
  return startuserid_;
}
inline int64_t Robot_Config_Ack::startuserid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.startuserid)
  return _internal_startuserid();
}
inline void Robot_Config_Ack::_internal_set_startuserid(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  startuserid_ = value;
}
inline void Robot_Config_Ack::set_startuserid(int64_t value) {
  _internal_set_startuserid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.startuserid)
}

// optional int32 users = 5;
inline bool Robot_Config_Ack::_internal_has_users() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_users() const {
  return _internal_has_users();
}
inline void Robot_Config_Ack::clear_users() {
  users_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Robot_Config_Ack::_internal_users() const {
  return users_;
}
inline int32_t Robot_Config_Ack::users() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.users)
  return _internal_users();
}
inline void Robot_Config_Ack::_internal_set_users(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  users_ = value;
}
inline void Robot_Config_Ack::set_users(int32_t value) {
  _internal_set_users(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.users)
}

// optional int32 usersrange = 6;
inline bool Robot_Config_Ack::_internal_has_usersrange() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_usersrange() const {
  return _internal_has_usersrange();
}
inline void Robot_Config_Ack::clear_usersrange() {
  usersrange_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t Robot_Config_Ack::_internal_usersrange() const {
  return usersrange_;
}
inline int32_t Robot_Config_Ack::usersrange() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.usersrange)
  return _internal_usersrange();
}
inline void Robot_Config_Ack::_internal_set_usersrange(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  usersrange_ = value;
}
inline void Robot_Config_Ack::set_usersrange(int32_t value) {
  _internal_set_usersrange(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.usersrange)
}

// optional string lgsip = 7;
inline bool Robot_Config_Ack::_internal_has_lgsip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_lgsip() const {
  return _internal_has_lgsip();
}
inline void Robot_Config_Ack::clear_lgsip() {
  lgsip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Robot_Config_Ack::lgsip() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.lgsip)
  return _internal_lgsip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Robot_Config_Ack::set_lgsip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 lgsip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.lgsip)
}
inline std::string* Robot_Config_Ack::mutable_lgsip() {
  std::string* _s = _internal_mutable_lgsip();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Config_Ack.lgsip)
  return _s;
}
inline const std::string& Robot_Config_Ack::_internal_lgsip() const {
  return lgsip_.Get();
}
inline void Robot_Config_Ack::_internal_set_lgsip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  lgsip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::_internal_mutable_lgsip() {
  _has_bits_[0] |= 0x00000001u;
  return lgsip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Robot_Config_Ack::release_lgsip() {
  // @@protoc_insertion_point(field_release:PRO.Robot_Config_Ack.lgsip)
  if (!_internal_has_lgsip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = lgsip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lgsip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lgsip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Robot_Config_Ack::set_allocated_lgsip(std::string* lgsip) {
  if (lgsip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lgsip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lgsip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lgsip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lgsip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_Config_Ack.lgsip)
}

// optional int32 lgsport = 8;
inline bool Robot_Config_Ack::_internal_has_lgsport() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Robot_Config_Ack::has_lgsport() const {
  return _internal_has_lgsport();
}
inline void Robot_Config_Ack::clear_lgsport() {
  lgsport_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t Robot_Config_Ack::_internal_lgsport() const {
  return lgsport_;
}
inline int32_t Robot_Config_Ack::lgsport() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Config_Ack.lgsport)
  return _internal_lgsport();
}
inline void Robot_Config_Ack::_internal_set_lgsport(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  lgsport_ = value;
}
inline void Robot_Config_Ack::set_lgsport(int32_t value) {
  _internal_set_lgsport(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Config_Ack.lgsport)
}

// -------------------------------------------------------------------

// Robot_Start_Ack

// int32 startusernum = 1;
inline void Robot_Start_Ack::clear_startusernum() {
  startusernum_ = 0;
}
inline int32_t Robot_Start_Ack::_internal_startusernum() const {
  return startusernum_;
}
inline int32_t Robot_Start_Ack::startusernum() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.startusernum)
  return _internal_startusernum();
}
inline void Robot_Start_Ack::_internal_set_startusernum(int32_t value) {
  
  startusernum_ = value;
}
inline void Robot_Start_Ack::set_startusernum(int32_t value) {
  _internal_set_startusernum(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.startusernum)
}

// int64 logininterval = 2;
inline void Robot_Start_Ack::clear_logininterval() {
  logininterval_ = int64_t{0};
}
inline int64_t Robot_Start_Ack::_internal_logininterval() const {
  return logininterval_;
}
inline int64_t Robot_Start_Ack::logininterval() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.logininterval)
  return _internal_logininterval();
}
inline void Robot_Start_Ack::_internal_set_logininterval(int64_t value) {
  
  logininterval_ = value;
}
inline void Robot_Start_Ack::set_logininterval(int64_t value) {
  _internal_set_logininterval(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.logininterval)
}

// repeated string behavior = 3;
inline int Robot_Start_Ack::_internal_behavior_size() const {
  return behavior_.size();
}
inline int Robot_Start_Ack::behavior_size() const {
  return _internal_behavior_size();
}
inline void Robot_Start_Ack::clear_behavior() {
  behavior_.Clear();
}
inline std::string* Robot_Start_Ack::add_behavior() {
  std::string* _s = _internal_add_behavior();
  // @@protoc_insertion_point(field_add_mutable:PRO.Robot_Start_Ack.behavior)
  return _s;
}
inline const std::string& Robot_Start_Ack::_internal_behavior(int index) const {
  return behavior_.Get(index);
}
inline const std::string& Robot_Start_Ack::behavior(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Robot_Start_Ack.behavior)
  return _internal_behavior(index);
}
inline std::string* Robot_Start_Ack::mutable_behavior(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Robot_Start_Ack.behavior)
  return behavior_.Mutable(index);
}
inline void Robot_Start_Ack::set_behavior(int index, const std::string& value) {
  behavior_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, std::string&& value) {
  behavior_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  behavior_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::set_behavior(int index, const char* value, size_t size) {
  behavior_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PRO.Robot_Start_Ack.behavior)
}
inline std::string* Robot_Start_Ack::_internal_add_behavior() {
  return behavior_.Add();
}
inline void Robot_Start_Ack::add_behavior(const std::string& value) {
  behavior_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(std::string&& value) {
  behavior_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  behavior_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PRO.Robot_Start_Ack.behavior)
}
inline void Robot_Start_Ack::add_behavior(const char* value, size_t size) {
  behavior_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PRO.Robot_Start_Ack.behavior)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Robot_Start_Ack::behavior() const {
  // @@protoc_insertion_point(field_list:PRO.Robot_Start_Ack.behavior)
  return behavior_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Robot_Start_Ack::mutable_behavior() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Robot_Start_Ack.behavior)
  return &behavior_;
}

// -------------------------------------------------------------------

// Robot_Stop_Ack

// -------------------------------------------------------------------

// Robot_State_Rpt_ActionGroup

// int64 actions = 1;
inline void Robot_State_Rpt_ActionGroup::clear_actions() {
  actions_ = int64_t{0};
}
inline int64_t Robot_State_Rpt_ActionGroup::_internal_actions() const {
  return actions_;
}
inline int64_t Robot_State_Rpt_ActionGroup::actions() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.ActionGroup.actions)
  return _internal_actions();
}
inline void Robot_State_Rpt_ActionGroup::_internal_set_actions(int64_t value) {
  
  actions_ = value;
}
inline void Robot_State_Rpt_ActionGroup::set_actions(int64_t value) {
  _internal_set_actions(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.ActionGroup.actions)
}

// int64 succeeds = 2;
inline void Robot_State_Rpt_ActionGroup::clear_succeeds() {
  succeeds_ = int64_t{0};
}
inline int64_t Robot_State_Rpt_ActionGroup::_internal_succeeds() const {
  return succeeds_;
}
inline int64_t Robot_State_Rpt_ActionGroup::succeeds() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.ActionGroup.succeeds)
  return _internal_succeeds();
}
inline void Robot_State_Rpt_ActionGroup::_internal_set_succeeds(int64_t value) {
  
  succeeds_ = value;
}
inline void Robot_State_Rpt_ActionGroup::set_succeeds(int64_t value) {
  _internal_set_succeeds(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.ActionGroup.succeeds)
}

// int64 faileds = 3;
inline void Robot_State_Rpt_ActionGroup::clear_faileds() {
  faileds_ = int64_t{0};
}
inline int64_t Robot_State_Rpt_ActionGroup::_internal_faileds() const {
  return faileds_;
}
inline int64_t Robot_State_Rpt_ActionGroup::faileds() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.ActionGroup.faileds)
  return _internal_faileds();
}
inline void Robot_State_Rpt_ActionGroup::_internal_set_faileds(int64_t value) {
  
  faileds_ = value;
}
inline void Robot_State_Rpt_ActionGroup::set_faileds(int64_t value) {
  _internal_set_faileds(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.ActionGroup.faileds)
}

// int64 timeouts = 4;
inline void Robot_State_Rpt_ActionGroup::clear_timeouts() {
  timeouts_ = int64_t{0};
}
inline int64_t Robot_State_Rpt_ActionGroup::_internal_timeouts() const {
  return timeouts_;
}
inline int64_t Robot_State_Rpt_ActionGroup::timeouts() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.ActionGroup.timeouts)
  return _internal_timeouts();
}
inline void Robot_State_Rpt_ActionGroup::_internal_set_timeouts(int64_t value) {
  
  timeouts_ = value;
}
inline void Robot_State_Rpt_ActionGroup::set_timeouts(int64_t value) {
  _internal_set_timeouts(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.ActionGroup.timeouts)
}

// int64 timeinterval = 5;
inline void Robot_State_Rpt_ActionGroup::clear_timeinterval() {
  timeinterval_ = int64_t{0};
}
inline int64_t Robot_State_Rpt_ActionGroup::_internal_timeinterval() const {
  return timeinterval_;
}
inline int64_t Robot_State_Rpt_ActionGroup::timeinterval() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.ActionGroup.timeinterval)
  return _internal_timeinterval();
}
inline void Robot_State_Rpt_ActionGroup::_internal_set_timeinterval(int64_t value) {
  
  timeinterval_ = value;
}
inline void Robot_State_Rpt_ActionGroup::set_timeinterval(int64_t value) {
  _internal_set_timeinterval(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.ActionGroup.timeinterval)
}

// -------------------------------------------------------------------

// Robot_State_Rpt_StateData

// .PRO.Robot_State_Rpt.ActionGroup logon = 1;
inline bool Robot_State_Rpt_StateData::_internal_has_logon() const {
  return this != internal_default_instance() && logon_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_logon() const {
  return _internal_has_logon();
}
inline void Robot_State_Rpt_StateData::clear_logon() {
  if (GetArenaForAllocation() == nullptr && logon_ != nullptr) {
    delete logon_;
  }
  logon_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_logon() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = logon_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::logon() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.logon)
  return _internal_logon();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_logon(
    ::PRO::Robot_State_Rpt_ActionGroup* logon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logon_);
  }
  logon_ = logon;
  if (logon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.logon)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_logon() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logon_;
  logon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_logon() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.logon)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logon_;
  logon_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_logon() {
  
  if (logon_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    logon_ = p;
  }
  return logon_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_logon() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_logon();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.logon)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_logon(::PRO::Robot_State_Rpt_ActionGroup* logon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logon_;
  }
  if (logon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(logon);
    if (message_arena != submessage_arena) {
      logon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logon, submessage_arena);
    }
    
  } else {
    
  }
  logon_ = logon;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.logon)
}

// .PRO.Robot_State_Rpt.ActionGroup getrole = 2;
inline bool Robot_State_Rpt_StateData::_internal_has_getrole() const {
  return this != internal_default_instance() && getrole_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_getrole() const {
  return _internal_has_getrole();
}
inline void Robot_State_Rpt_StateData::clear_getrole() {
  if (GetArenaForAllocation() == nullptr && getrole_ != nullptr) {
    delete getrole_;
  }
  getrole_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_getrole() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = getrole_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::getrole() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.getrole)
  return _internal_getrole();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_getrole(
    ::PRO::Robot_State_Rpt_ActionGroup* getrole) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getrole_);
  }
  getrole_ = getrole;
  if (getrole) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.getrole)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_getrole() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getrole_;
  getrole_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_getrole() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.getrole)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getrole_;
  getrole_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_getrole() {
  
  if (getrole_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    getrole_ = p;
  }
  return getrole_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_getrole() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_getrole();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.getrole)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_getrole(::PRO::Robot_State_Rpt_ActionGroup* getrole) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getrole_;
  }
  if (getrole) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(getrole);
    if (message_arena != submessage_arena) {
      getrole = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getrole, submessage_arena);
    }
    
  } else {
    
  }
  getrole_ = getrole;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.getrole)
}

// .PRO.Robot_State_Rpt.ActionGroup selrole = 3;
inline bool Robot_State_Rpt_StateData::_internal_has_selrole() const {
  return this != internal_default_instance() && selrole_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_selrole() const {
  return _internal_has_selrole();
}
inline void Robot_State_Rpt_StateData::clear_selrole() {
  if (GetArenaForAllocation() == nullptr && selrole_ != nullptr) {
    delete selrole_;
  }
  selrole_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_selrole() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = selrole_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::selrole() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.selrole)
  return _internal_selrole();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_selrole(
    ::PRO::Robot_State_Rpt_ActionGroup* selrole) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selrole_);
  }
  selrole_ = selrole;
  if (selrole) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.selrole)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_selrole() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = selrole_;
  selrole_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_selrole() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.selrole)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = selrole_;
  selrole_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_selrole() {
  
  if (selrole_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    selrole_ = p;
  }
  return selrole_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_selrole() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_selrole();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.selrole)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_selrole(::PRO::Robot_State_Rpt_ActionGroup* selrole) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete selrole_;
  }
  if (selrole) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(selrole);
    if (message_arena != submessage_arena) {
      selrole = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selrole, submessage_arena);
    }
    
  } else {
    
  }
  selrole_ = selrole;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.selrole)
}

// .PRO.Robot_State_Rpt.ActionGroup getchannel = 4;
inline bool Robot_State_Rpt_StateData::_internal_has_getchannel() const {
  return this != internal_default_instance() && getchannel_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_getchannel() const {
  return _internal_has_getchannel();
}
inline void Robot_State_Rpt_StateData::clear_getchannel() {
  if (GetArenaForAllocation() == nullptr && getchannel_ != nullptr) {
    delete getchannel_;
  }
  getchannel_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_getchannel() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = getchannel_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::getchannel() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.getchannel)
  return _internal_getchannel();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_getchannel(
    ::PRO::Robot_State_Rpt_ActionGroup* getchannel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getchannel_);
  }
  getchannel_ = getchannel;
  if (getchannel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.getchannel)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_getchannel() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getchannel_;
  getchannel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_getchannel() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.getchannel)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getchannel_;
  getchannel_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_getchannel() {
  
  if (getchannel_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    getchannel_ = p;
  }
  return getchannel_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_getchannel() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_getchannel();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.getchannel)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_getchannel(::PRO::Robot_State_Rpt_ActionGroup* getchannel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getchannel_;
  }
  if (getchannel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(getchannel);
    if (message_arena != submessage_arena) {
      getchannel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getchannel, submessage_arena);
    }
    
  } else {
    
  }
  getchannel_ = getchannel;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.getchannel)
}

// .PRO.Robot_State_Rpt.ActionGroup selchannel = 5;
inline bool Robot_State_Rpt_StateData::_internal_has_selchannel() const {
  return this != internal_default_instance() && selchannel_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_selchannel() const {
  return _internal_has_selchannel();
}
inline void Robot_State_Rpt_StateData::clear_selchannel() {
  if (GetArenaForAllocation() == nullptr && selchannel_ != nullptr) {
    delete selchannel_;
  }
  selchannel_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_selchannel() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = selchannel_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::selchannel() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.selchannel)
  return _internal_selchannel();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_selchannel(
    ::PRO::Robot_State_Rpt_ActionGroup* selchannel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selchannel_);
  }
  selchannel_ = selchannel;
  if (selchannel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.selchannel)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_selchannel() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = selchannel_;
  selchannel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_selchannel() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.selchannel)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = selchannel_;
  selchannel_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_selchannel() {
  
  if (selchannel_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    selchannel_ = p;
  }
  return selchannel_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_selchannel() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_selchannel();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.selchannel)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_selchannel(::PRO::Robot_State_Rpt_ActionGroup* selchannel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete selchannel_;
  }
  if (selchannel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(selchannel);
    if (message_arena != submessage_arena) {
      selchannel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selchannel, submessage_arena);
    }
    
  } else {
    
  }
  selchannel_ = selchannel;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.selchannel)
}

// .PRO.Robot_State_Rpt.ActionGroup getroom = 6;
inline bool Robot_State_Rpt_StateData::_internal_has_getroom() const {
  return this != internal_default_instance() && getroom_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_getroom() const {
  return _internal_has_getroom();
}
inline void Robot_State_Rpt_StateData::clear_getroom() {
  if (GetArenaForAllocation() == nullptr && getroom_ != nullptr) {
    delete getroom_;
  }
  getroom_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_getroom() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = getroom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::getroom() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.getroom)
  return _internal_getroom();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_getroom(
    ::PRO::Robot_State_Rpt_ActionGroup* getroom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getroom_);
  }
  getroom_ = getroom;
  if (getroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.getroom)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_getroom() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getroom_;
  getroom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_getroom() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.getroom)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = getroom_;
  getroom_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_getroom() {
  
  if (getroom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    getroom_ = p;
  }
  return getroom_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_getroom() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_getroom();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.getroom)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_getroom(::PRO::Robot_State_Rpt_ActionGroup* getroom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete getroom_;
  }
  if (getroom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(getroom);
    if (message_arena != submessage_arena) {
      getroom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getroom, submessage_arena);
    }
    
  } else {
    
  }
  getroom_ = getroom;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.getroom)
}

// .PRO.Robot_State_Rpt.ActionGroup loginroom = 7;
inline bool Robot_State_Rpt_StateData::_internal_has_loginroom() const {
  return this != internal_default_instance() && loginroom_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_loginroom() const {
  return _internal_has_loginroom();
}
inline void Robot_State_Rpt_StateData::clear_loginroom() {
  if (GetArenaForAllocation() == nullptr && loginroom_ != nullptr) {
    delete loginroom_;
  }
  loginroom_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_loginroom() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = loginroom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::loginroom() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.loginroom)
  return _internal_loginroom();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_loginroom(
    ::PRO::Robot_State_Rpt_ActionGroup* loginroom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loginroom_);
  }
  loginroom_ = loginroom;
  if (loginroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.loginroom)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_loginroom() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = loginroom_;
  loginroom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_loginroom() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.loginroom)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = loginroom_;
  loginroom_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_loginroom() {
  
  if (loginroom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    loginroom_ = p;
  }
  return loginroom_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_loginroom() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_loginroom();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.loginroom)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_loginroom(::PRO::Robot_State_Rpt_ActionGroup* loginroom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete loginroom_;
  }
  if (loginroom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(loginroom);
    if (message_arena != submessage_arena) {
      loginroom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loginroom, submessage_arena);
    }
    
  } else {
    
  }
  loginroom_ = loginroom;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.loginroom)
}

// .PRO.Robot_State_Rpt.ActionGroup logoutroom = 8;
inline bool Robot_State_Rpt_StateData::_internal_has_logoutroom() const {
  return this != internal_default_instance() && logoutroom_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_logoutroom() const {
  return _internal_has_logoutroom();
}
inline void Robot_State_Rpt_StateData::clear_logoutroom() {
  if (GetArenaForAllocation() == nullptr && logoutroom_ != nullptr) {
    delete logoutroom_;
  }
  logoutroom_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_logoutroom() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = logoutroom_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::logoutroom() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.logoutroom)
  return _internal_logoutroom();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_logoutroom(
    ::PRO::Robot_State_Rpt_ActionGroup* logoutroom) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logoutroom_);
  }
  logoutroom_ = logoutroom;
  if (logoutroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.logoutroom)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_logoutroom() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logoutroom_;
  logoutroom_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_logoutroom() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.logoutroom)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logoutroom_;
  logoutroom_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_logoutroom() {
  
  if (logoutroom_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    logoutroom_ = p;
  }
  return logoutroom_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_logoutroom() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_logoutroom();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.logoutroom)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_logoutroom(::PRO::Robot_State_Rpt_ActionGroup* logoutroom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logoutroom_;
  }
  if (logoutroom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(logoutroom);
    if (message_arena != submessage_arena) {
      logoutroom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logoutroom, submessage_arena);
    }
    
  } else {
    
  }
  logoutroom_ = logoutroom;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.logoutroom)
}

// .PRO.Robot_State_Rpt.ActionGroup logoutchannel = 9;
inline bool Robot_State_Rpt_StateData::_internal_has_logoutchannel() const {
  return this != internal_default_instance() && logoutchannel_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_logoutchannel() const {
  return _internal_has_logoutchannel();
}
inline void Robot_State_Rpt_StateData::clear_logoutchannel() {
  if (GetArenaForAllocation() == nullptr && logoutchannel_ != nullptr) {
    delete logoutchannel_;
  }
  logoutchannel_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_logoutchannel() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = logoutchannel_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::logoutchannel() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.logoutchannel)
  return _internal_logoutchannel();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_logoutchannel(
    ::PRO::Robot_State_Rpt_ActionGroup* logoutchannel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logoutchannel_);
  }
  logoutchannel_ = logoutchannel;
  if (logoutchannel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.logoutchannel)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_logoutchannel() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logoutchannel_;
  logoutchannel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_logoutchannel() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.logoutchannel)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logoutchannel_;
  logoutchannel_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_logoutchannel() {
  
  if (logoutchannel_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    logoutchannel_ = p;
  }
  return logoutchannel_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_logoutchannel() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_logoutchannel();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.logoutchannel)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_logoutchannel(::PRO::Robot_State_Rpt_ActionGroup* logoutchannel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logoutchannel_;
  }
  if (logoutchannel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(logoutchannel);
    if (message_arena != submessage_arena) {
      logoutchannel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logoutchannel, submessage_arena);
    }
    
  } else {
    
  }
  logoutchannel_ = logoutchannel;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.logoutchannel)
}

// .PRO.Robot_State_Rpt.ActionGroup logout = 10;
inline bool Robot_State_Rpt_StateData::_internal_has_logout() const {
  return this != internal_default_instance() && logout_ != nullptr;
}
inline bool Robot_State_Rpt_StateData::has_logout() const {
  return _internal_has_logout();
}
inline void Robot_State_Rpt_StateData::clear_logout() {
  if (GetArenaForAllocation() == nullptr && logout_ != nullptr) {
    delete logout_;
  }
  logout_ = nullptr;
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::_internal_logout() const {
  const ::PRO::Robot_State_Rpt_ActionGroup* p = logout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PRO::Robot_State_Rpt_ActionGroup&>(
      ::PRO::_Robot_State_Rpt_ActionGroup_default_instance_);
}
inline const ::PRO::Robot_State_Rpt_ActionGroup& Robot_State_Rpt_StateData::logout() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.StateData.logout)
  return _internal_logout();
}
inline void Robot_State_Rpt_StateData::unsafe_arena_set_allocated_logout(
    ::PRO::Robot_State_Rpt_ActionGroup* logout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logout_);
  }
  logout_ = logout;
  if (logout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PRO.Robot_State_Rpt.StateData.logout)
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::release_logout() {
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logout_;
  logout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::unsafe_arena_release_logout() {
  // @@protoc_insertion_point(field_release:PRO.Robot_State_Rpt.StateData.logout)
  
  ::PRO::Robot_State_Rpt_ActionGroup* temp = logout_;
  logout_ = nullptr;
  return temp;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::_internal_mutable_logout() {
  
  if (logout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PRO::Robot_State_Rpt_ActionGroup>(GetArenaForAllocation());
    logout_ = p;
  }
  return logout_;
}
inline ::PRO::Robot_State_Rpt_ActionGroup* Robot_State_Rpt_StateData::mutable_logout() {
  ::PRO::Robot_State_Rpt_ActionGroup* _msg = _internal_mutable_logout();
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.StateData.logout)
  return _msg;
}
inline void Robot_State_Rpt_StateData::set_allocated_logout(::PRO::Robot_State_Rpt_ActionGroup* logout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logout_;
  }
  if (logout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::PRO::Robot_State_Rpt_ActionGroup>::GetOwningArena(logout);
    if (message_arena != submessage_arena) {
      logout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logout, submessage_arena);
    }
    
  } else {
    
  }
  logout_ = logout;
  // @@protoc_insertion_point(field_set_allocated:PRO.Robot_State_Rpt.StateData.logout)
}

// -------------------------------------------------------------------

// Robot_State_Rpt

// int64 robotid = 1;
inline void Robot_State_Rpt::clear_robotid() {
  robotid_ = int64_t{0};
}
inline int64_t Robot_State_Rpt::_internal_robotid() const {
  return robotid_;
}
inline int64_t Robot_State_Rpt::robotid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.robotid)
  return _internal_robotid();
}
inline void Robot_State_Rpt::_internal_set_robotid(int64_t value) {
  
  robotid_ = value;
}
inline void Robot_State_Rpt::set_robotid(int64_t value) {
  _internal_set_robotid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Rpt.robotid)
}

// repeated .PRO.Robot_State_Rpt.StateData stat_data = 2;
inline int Robot_State_Rpt::_internal_stat_data_size() const {
  return stat_data_.size();
}
inline int Robot_State_Rpt::stat_data_size() const {
  return _internal_stat_data_size();
}
inline void Robot_State_Rpt::clear_stat_data() {
  stat_data_.Clear();
}
inline ::PRO::Robot_State_Rpt_StateData* Robot_State_Rpt::mutable_stat_data(int index) {
  // @@protoc_insertion_point(field_mutable:PRO.Robot_State_Rpt.stat_data)
  return stat_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Robot_State_Rpt_StateData >*
Robot_State_Rpt::mutable_stat_data() {
  // @@protoc_insertion_point(field_mutable_list:PRO.Robot_State_Rpt.stat_data)
  return &stat_data_;
}
inline const ::PRO::Robot_State_Rpt_StateData& Robot_State_Rpt::_internal_stat_data(int index) const {
  return stat_data_.Get(index);
}
inline const ::PRO::Robot_State_Rpt_StateData& Robot_State_Rpt::stat_data(int index) const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Rpt.stat_data)
  return _internal_stat_data(index);
}
inline ::PRO::Robot_State_Rpt_StateData* Robot_State_Rpt::_internal_add_stat_data() {
  return stat_data_.Add();
}
inline ::PRO::Robot_State_Rpt_StateData* Robot_State_Rpt::add_stat_data() {
  ::PRO::Robot_State_Rpt_StateData* _add = _internal_add_stat_data();
  // @@protoc_insertion_point(field_add:PRO.Robot_State_Rpt.stat_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PRO::Robot_State_Rpt_StateData >&
Robot_State_Rpt::stat_data() const {
  // @@protoc_insertion_point(field_list:PRO.Robot_State_Rpt.stat_data)
  return stat_data_;
}

// -------------------------------------------------------------------

// Robot_State_Ack

// int64 userid = 1;
inline void Robot_State_Ack::clear_userid() {
  userid_ = int64_t{0};
}
inline int64_t Robot_State_Ack::_internal_userid() const {
  return userid_;
}
inline int64_t Robot_State_Ack::userid() const {
  // @@protoc_insertion_point(field_get:PRO.Robot_State_Ack.userid)
  return _internal_userid();
}
inline void Robot_State_Ack::_internal_set_userid(int64_t value) {
  
  userid_ = value;
}
inline void Robot_State_Ack::set_userid(int64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:PRO.Robot_State_Ack.userid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PRO

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PRO::ROBOT_CONST> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PRO::ROBOT_CONST>() {
  return ::PRO::ROBOT_CONST_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_5ftest_5finternal_2eproto
